/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/activitypub/user-id/{user-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the Person actor for a user */
        get: operations["activitypubPerson"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/activitypub/user-id/{user-id}/inbox": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Send to the inbox */
        post: operations["activitypubPersonInbox"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/actions/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all jobs */
        get: operations["listAdminWorkflowJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/actions/runners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all runners */
        get: operations["getAdminRunners"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/actions/runners/registration-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Get an global actions runner registration token */
        post: operations["adminCreateRunnerRegistrationToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/actions/runners/{runner_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an global runner */
        get: operations["getAdminRunner"];
        put?: never;
        post?: never;
        /** Delete an global runner */
        delete: operations["deleteAdminRunner"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/actions/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all runs */
        get: operations["listAdminWorkflowRuns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/cron": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List cron tasks */
        get: operations["adminCronList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/cron/{task}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Run cron task */
        post: operations["adminCronRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/emails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all emails */
        get: operations["adminGetAllEmails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/emails/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search all emails */
        get: operations["adminSearchEmails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/hooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List system's webhooks */
        get: operations["adminListHooks"];
        put?: never;
        /** Create a hook */
        post: operations["adminCreateHook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/hooks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a hook */
        get: operations["adminGetHook"];
        put?: never;
        post?: never;
        /** Delete a hook */
        delete: operations["adminDeleteHook"];
        options?: never;
        head?: never;
        /** Update a hook */
        patch: operations["adminEditHook"];
        trace?: never;
    };
    "/admin/orgs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all organizations */
        get: operations["adminGetAllOrgs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/runners/registration-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an global actions runner registration token */
        get: operations["adminGetRunnerRegistrationToken"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/unadopted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List unadopted repositories */
        get: operations["adminUnadoptedList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/unadopted/{owner}/{repo}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Adopt unadopted files as a repository */
        post: operations["adminAdoptRepository"];
        /** Delete unadopted files */
        delete: operations["adminDeleteUnadoptedRepository"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search users according filter conditions */
        get: operations["adminSearchUsers"];
        put?: never;
        /** Create a user */
        post: operations["adminCreateUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a user */
        delete: operations["adminDeleteUser"];
        options?: never;
        head?: never;
        /** Edit an existing user */
        patch: operations["adminEditUser"];
        trace?: never;
    };
    "/admin/users/{username}/badges": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a user's badges */
        get: operations["adminListUserBadges"];
        put?: never;
        /** Add a badge to a user */
        post: operations["adminAddUserBadges"];
        /** Remove a badge from a user */
        delete: operations["adminDeleteUserBadges"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users/{username}/keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Add a public key on behalf of a user */
        post: operations["adminCreatePublicKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users/{username}/keys/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a user's public key */
        delete: operations["adminDeleteUserPublicKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users/{username}/orgs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create an organization */
        post: operations["adminCreateOrg"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users/{username}/rename": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Rename a user */
        post: operations["adminRenameUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/users/{username}/repos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a repository on behalf of a user */
        post: operations["adminCreateRepo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gitignore/templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of all gitignore templates */
        get: operations["listGitignoresTemplates"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gitignore/templates/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns information about a gitignore template */
        get: operations["getGitignoreTemplateInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/label/templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of all label templates */
        get: operations["listLabelTemplates"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/label/templates/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns all labels in a template */
        get: operations["getLabelTemplateInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/licenses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of all license templates */
        get: operations["listLicenseTemplates"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/licenses/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns information about a license template */
        get: operations["getLicenseTemplateInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/markdown": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Render a markdown document as HTML */
        post: operations["renderMarkdown"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/markdown/raw": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Render raw markdown as HTML */
        post: operations["renderMarkdownRaw"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/markup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Render a markup document as HTML */
        post: operations["renderMarkup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodeinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the nodeinfo of the Gitea application */
        get: operations["getNodeInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List users's notification threads */
        get: operations["notifyGetList"];
        /** Mark notification threads as read, pinned or unread */
        put: operations["notifyReadList"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications/new": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if unread notifications exist */
        get: operations["notifyNewAvailable"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications/threads/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get notification thread by ID */
        get: operations["notifyGetThread"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Mark notification thread as read by ID */
        patch: operations["notifyReadThread"];
        trace?: never;
    };
    "/org/{org}/repos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a repository in an organization
         * @deprecated
         */
        post: operations["createOrgRepoDeprecated"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of organizations */
        get: operations["orgGetAll"];
        put?: never;
        /** Create an organization */
        post: operations["orgCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an organization */
        get: operations["orgGet"];
        put?: never;
        post?: never;
        /** Delete an organization */
        delete: operations["orgDelete"];
        options?: never;
        head?: never;
        /** Edit an organization */
        patch: operations["orgEdit"];
        trace?: never;
    };
    "/orgs/{org}/actions/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get org-level workflow jobs */
        get: operations["getOrgWorkflowJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/runners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get org-level runners */
        get: operations["getOrgRunners"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/runners/registration-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an organization's actions runner registration token */
        get: operations["orgGetRunnerRegistrationToken"];
        put?: never;
        /** Get an organization's actions runner registration token */
        post: operations["orgCreateRunnerRegistrationToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/runners/{runner_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an org-level runner */
        get: operations["getOrgRunner"];
        put?: never;
        post?: never;
        /** Delete an org-level runner */
        delete: operations["deleteOrgRunner"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get org-level workflow runs */
        get: operations["getOrgWorkflowRuns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/secrets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's actions secrets */
        get: operations["orgListActionsSecrets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/secrets/{secretname}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Create or Update a secret value in an organization */
        put: operations["updateOrgSecret"];
        post?: never;
        /** Delete a secret in an organization */
        delete: operations["deleteOrgSecret"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/variables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an org-level variables list */
        get: operations["getOrgVariablesList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/actions/variables/{variablename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an org-level variable */
        get: operations["getOrgVariable"];
        /** Update an org-level variable */
        put: operations["updateOrgVariable"];
        /** Create an org-level variable */
        post: operations["createOrgVariable"];
        /** Delete an org-level variable */
        delete: operations["deleteOrgVariable"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/activities/feeds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's activity feeds */
        get: operations["orgListActivityFeeds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/avatar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update Avatar */
        post: operations["orgUpdateAvatar"];
        /** Delete Avatar */
        delete: operations["orgDeleteAvatar"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/blocks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List users blocked by the organization */
        get: operations["organizationListBlocks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/blocks/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a user is blocked by the organization */
        get: operations["organizationCheckUserBlock"];
        /** Block a user */
        put: operations["organizationBlockUser"];
        post?: never;
        /** Unblock a user */
        delete: operations["organizationUnblockUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/hooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's webhooks */
        get: operations["orgListHooks"];
        put?: never;
        /** Create a hook */
        post: operations["orgCreateHook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/hooks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a hook */
        get: operations["orgGetHook"];
        put?: never;
        post?: never;
        /** Delete a hook */
        delete: operations["orgDeleteHook"];
        options?: never;
        head?: never;
        /** Update a hook */
        patch: operations["orgEditHook"];
        trace?: never;
    };
    "/orgs/{org}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's labels */
        get: operations["orgListLabels"];
        put?: never;
        /** Create a label for an organization */
        post: operations["orgCreateLabel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/labels/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a single label */
        get: operations["orgGetLabel"];
        put?: never;
        post?: never;
        /** Delete a label */
        delete: operations["orgDeleteLabel"];
        options?: never;
        head?: never;
        /** Update a label */
        patch: operations["orgEditLabel"];
        trace?: never;
    };
    "/orgs/{org}/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's members */
        get: operations["orgListMembers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/members/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a user is a member of an organization */
        get: operations["orgIsMember"];
        put?: never;
        post?: never;
        /** Remove a member from an organization */
        delete: operations["orgDeleteMember"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/public_members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's public members */
        get: operations["orgListPublicMembers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/public_members/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a user is a public member of an organization */
        get: operations["orgIsPublicMember"];
        /** Publicize a user's membership */
        put: operations["orgPublicizeMember"];
        post?: never;
        /** Conceal a user's membership */
        delete: operations["orgConcealMember"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/rename": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Rename an organization */
        post: operations["renameOrg"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/repos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's repos */
        get: operations["orgListRepos"];
        put?: never;
        /** Create a repository in an organization */
        post: operations["createOrgRepo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an organization's teams */
        get: operations["orgListTeams"];
        put?: never;
        /** Create a team */
        post: operations["orgCreateTeam"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/orgs/{org}/teams/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search for teams within an organization */
        get: operations["teamSearch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets all packages of an owner */
        get: operations["listPackages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}/{type}/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets all versions of a package */
        get: operations["listPackageVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}/{type}/{name}/-/latest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the latest version of a package */
        get: operations["getLatestPackageVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}/{type}/{name}/-/link/{repo_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Link a package to a repository */
        post: operations["linkPackage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}/{type}/{name}/-/unlink": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Unlink a package from a repository */
        post: operations["unlinkPackage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}/{type}/{name}/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a package */
        get: operations["getPackage"];
        put?: never;
        post?: never;
        /** Delete a package */
        delete: operations["deletePackage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/packages/{owner}/{type}/{name}/{version}/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets all files of a package */
        get: operations["listPackageFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/issues/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search for issues across the repositories that the user has access to */
        get: operations["issueSearchIssues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/migrate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Migrate a remote git repository */
        post: operations["repoMigrate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search for repositories */
        get: operations["repoSearch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a repository */
        get: operations["repoGet"];
        put?: never;
        post?: never;
        /** Delete a repository */
        delete: operations["repoDelete"];
        options?: never;
        head?: never;
        /** Edit a repository's properties. Only fields that are set will be changed. */
        patch: operations["repoEdit"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/artifacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all artifacts for a repository */
        get: operations["getArtifacts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a specific artifact for a workflow run */
        get: operations["getArtifact"];
        put?: never;
        post?: never;
        /** Deletes a specific artifact for a workflow run */
        delete: operations["deleteArtifact"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/zip": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Downloads a specific artifact for a workflow run redirects to blob url */
        get: operations["downloadArtifact"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all jobs for a repository */
        get: operations["listWorkflowJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/jobs/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a specific workflow job for a workflow run */
        get: operations["getWorkflowJob"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/jobs/{job_id}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Downloads the job logs for a workflow run */
        get: operations["downloadActionsRunJobLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get repo-level runners */
        get: operations["getRepoRunners"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runners/registration-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a repository's actions runner registration token */
        get: operations["repoGetRunnerRegistrationToken"];
        put?: never;
        /** Get a repository's actions runner registration token */
        post: operations["repoCreateRunnerRegistrationToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runners/{runner_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an repo-level runner */
        get: operations["getRepoRunner"];
        put?: never;
        post?: never;
        /** Delete an repo-level runner */
        delete: operations["deleteRepoRunner"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all runs for a repository run */
        get: operations["getWorkflowRuns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runs/{run}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a specific workflow run */
        get: operations["GetWorkflowRun"];
        put?: never;
        post?: never;
        /** Delete a workflow run */
        delete: operations["deleteActionRun"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runs/{run}/artifacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all artifacts for a repository run */
        get: operations["getArtifactsOfRun"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/runs/{run}/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lists all jobs for a workflow run */
        get: operations["listWorkflowRunJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/secrets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an repo's actions secrets */
        get: operations["repoListActionsSecrets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/secrets/{secretname}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Create or Update a secret value in a repository */
        put: operations["updateRepoSecret"];
        post?: never;
        /** Delete a secret in a repository */
        delete: operations["deleteRepoSecret"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's action tasks */
        get: operations["ListActionTasks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/variables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get repo-level variables list */
        get: operations["getRepoVariablesList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/variables/{variablename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a repo-level variable */
        get: operations["getRepoVariable"];
        /** Update a repo-level variable */
        put: operations["updateRepoVariable"];
        /** Create a repo-level variable */
        post: operations["createRepoVariable"];
        /** Delete a repo-level variable */
        delete: operations["deleteRepoVariable"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/workflows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List repository workflows */
        get: operations["ActionsListRepositoryWorkflows"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/workflows/{workflow_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a workflow */
        get: operations["ActionsGetWorkflow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Disable a workflow */
        put: operations["ActionsDisableWorkflow"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a workflow dispatch event */
        post: operations["ActionsDispatchWorkflow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Enable a workflow */
        put: operations["ActionsEnableWorkflow"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/activities/feeds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's activity feeds */
        get: operations["repoListActivityFeeds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/archive/{archive}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an archive of a repository */
        get: operations["repoGetArchive"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/assignees": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return all users that have write access and can be assigned to issues */
        get: operations["repoGetAssignees"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/avatar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update avatar */
        post: operations["repoUpdateAvatar"];
        /** Delete avatar */
        delete: operations["repoDeleteAvatar"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/branch_protections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List branch protections for a repository */
        get: operations["repoListBranchProtection"];
        put?: never;
        /** Create a branch protections for a repository */
        post: operations["repoCreateBranchProtection"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/branch_protections/priority": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update the priorities of branch protections for a repository. */
        post: operations["repoUpdateBranchProtectionPriories"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/branch_protections/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a specific branch protection for the repository */
        get: operations["repoGetBranchProtection"];
        put?: never;
        post?: never;
        /** Delete a specific branch protection for the repository */
        delete: operations["repoDeleteBranchProtection"];
        options?: never;
        head?: never;
        /** Edit a branch protections for a repository. Only fields that are set will be changed */
        patch: operations["repoEditBranchProtection"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/branches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's branches */
        get: operations["repoListBranches"];
        put?: never;
        /** Create a branch */
        post: operations["repoCreateBranch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/branches/{branch}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve a specific branch from a repository, including its effective branch protection */
        get: operations["repoGetBranch"];
        put?: never;
        post?: never;
        /** Delete a specific branch from a repository */
        delete: operations["repoDeleteBranch"];
        options?: never;
        head?: never;
        /** Rename a branch */
        patch: operations["repoRenameBranch"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/collaborators": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's collaborators */
        get: operations["repoListCollaborators"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/collaborators/{collaborator}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a user is a collaborator of a repository */
        get: operations["repoCheckCollaborator"];
        /** Add or Update a collaborator to a repository */
        put: operations["repoAddCollaborator"];
        post?: never;
        /** Delete a collaborator from a repository */
        delete: operations["repoDeleteCollaborator"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/collaborators/{collaborator}/permission": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get repository permissions for a user */
        get: operations["repoGetRepoPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/commits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a list of all commits from a repository */
        get: operations["repoGetAllCommits"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/commits/{ref}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a commit's combined status, by branch/tag/commit reference */
        get: operations["repoGetCombinedStatusByRef"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/commits/{ref}/statuses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a commit's statuses, by branch/tag/commit reference */
        get: operations["repoListStatusesByRef"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/commits/{sha}/pull": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the merged pull request of the commit */
        get: operations["repoGetCommitPullRequest"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/compare/{basehead}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get commit comparison information */
        get: operations["repoCompareDiff"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/contents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the metadata of all the entries of the root dir.
         * @description This API follows GitHub's design, and it is not easy to use. Recommend users to use our "contents-ext" API instead.
         */
        get: operations["repoGetContentsList"];
        put?: never;
        /** Modify multiple files in a repository */
        post: operations["repoChangeFiles"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/contents-ext/{filepath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * The extended "contents" API, to get file metadata and/or content, or list a directory.
         * @description It guarantees that only one of the response fields is set if the request succeeds. Users can pass "includes=file_content" or "includes=lfs_metadata" to retrieve more fields. "includes=file_content" only works for single file, if you need to retrieve file contents in batch, use "file-contents" API after listing the directory.
         */
        get: operations["repoGetContentsExt"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/contents/{filepath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir.
         * @description This API follows GitHub's design, and it is not easy to use. Recommend users to use the "contents-ext" API instead.
         */
        get: operations["repoGetContents"];
        /** Update a file in a repository */
        put: operations["repoUpdateFile"];
        /** Create a file in a repository */
        post: operations["repoCreateFile"];
        /** Delete a file in a repository */
        delete: operations["repoDeleteFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/diffpatch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Apply diff patch to repository */
        post: operations["repoApplyDiffPatch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/editorconfig/{filepath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the EditorConfig definitions of a file in a repository */
        get: operations["repoGetEditorConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/file-contents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the metadata and contents of requested files
         * @description See the POST method. This GET method supports using JSON encoded request body in query parameter.
         */
        get: operations["repoGetFileContents"];
        put?: never;
        /**
         * Get the metadata and contents of requested files
         * @description Uses automatic pagination based on default page size and max response size and returns the maximum allowed number of files. Files which could not be retrieved are null. Files which are too large are being returned with `encoding == null`, `content == null` and `size > 0`, they can be requested separately by using the `download_url`.
         */
        post: operations["repoGetFileContentsPost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/forks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's forks */
        get: operations["listForks"];
        put?: never;
        /** Fork a repository */
        post: operations["createFork"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/blobs/{sha}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the blob of a repository. */
        get: operations["GetBlob"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/commits/{sha}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a single commit from a repository */
        get: operations["repoGetSingleCommit"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/commits/{sha}.{diffType}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a commit's diff or patch */
        get: operations["repoDownloadCommitDiffOrPatch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/notes/{sha}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a note corresponding to a single commit from a repository */
        get: operations["repoGetNote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/refs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get specified ref or filtered repository's refs */
        get: operations["repoListAllGitRefs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/refs/{ref}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get specified ref or filtered repository's refs */
        get: operations["repoListGitRefs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/tags/{sha}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the tag object of an annotated tag (not lightweight tags) */
        get: operations["GetAnnotatedTag"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/git/trees/{sha}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the tree of a repository. */
        get: operations["GetTree"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/hooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the hooks in a repository */
        get: operations["repoListHooks"];
        put?: never;
        /** Create a hook */
        post: operations["repoCreateHook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/hooks/git": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the Git hooks in a repository */
        get: operations["repoListGitHooks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/hooks/git/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a Git hook */
        get: operations["repoGetGitHook"];
        put?: never;
        post?: never;
        /** Delete a Git hook in a repository */
        delete: operations["repoDeleteGitHook"];
        options?: never;
        head?: never;
        /** Edit a Git hook in a repository */
        patch: operations["repoEditGitHook"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/hooks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a hook */
        get: operations["repoGetHook"];
        put?: never;
        post?: never;
        /** Delete a hook in a repository */
        delete: operations["repoDeleteHook"];
        options?: never;
        head?: never;
        /** Edit a hook in a repository */
        patch: operations["repoEditHook"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/hooks/{id}/tests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Test a push webhook */
        post: operations["repoTestHook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issue_config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the issue config for a repo */
        get: operations["repoGetIssueConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issue_config/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the validation information for a issue config */
        get: operations["repoValidateIssueConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issue_templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get available issue templates for a repository */
        get: operations["repoGetIssueTemplates"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's issues */
        get: operations["issueListIssues"];
        put?: never;
        /** Create an issue. If using deadline only the date will be taken into account, and time of day ignored. */
        post: operations["issueCreateIssue"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all comments in a repository */
        get: operations["issueGetRepoComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/comments/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a comment */
        get: operations["issueGetComment"];
        put?: never;
        post?: never;
        /** Delete a comment */
        delete: operations["issueDeleteComment"];
        options?: never;
        head?: never;
        /** Edit a comment */
        patch: operations["issueEditComment"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/comments/{id}/assets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List comment's attachments */
        get: operations["issueListIssueCommentAttachments"];
        put?: never;
        /** Create a comment attachment */
        post: operations["issueCreateIssueCommentAttachment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a comment attachment */
        get: operations["issueGetIssueCommentAttachment"];
        put?: never;
        post?: never;
        /** Delete a comment attachment */
        delete: operations["issueDeleteIssueCommentAttachment"];
        options?: never;
        head?: never;
        /** Edit a comment attachment */
        patch: operations["issueEditIssueCommentAttachment"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/comments/{id}/reactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a list of reactions from a comment of an issue */
        get: operations["issueGetCommentReactions"];
        put?: never;
        /** Add a reaction to a comment of an issue */
        post: operations["issuePostCommentReaction"];
        /** Remove a reaction from a comment of an issue */
        delete: operations["issueDeleteCommentReaction"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/pinned": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's pinned issues */
        get: operations["repoListPinnedIssues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an issue */
        get: operations["issueGetIssue"];
        put?: never;
        post?: never;
        /** Delete an issue */
        delete: operations["issueDelete"];
        options?: never;
        head?: never;
        /** Edit an issue. If using deadline only the date will be taken into account, and time of day ignored. */
        patch: operations["issueEditIssue"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/assets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List issue's attachments */
        get: operations["issueListIssueAttachments"];
        put?: never;
        /** Create an issue attachment */
        post: operations["issueCreateIssueAttachment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an issue attachment */
        get: operations["issueGetIssueAttachment"];
        put?: never;
        post?: never;
        /** Delete an issue attachment */
        delete: operations["issueDeleteIssueAttachment"];
        options?: never;
        head?: never;
        /** Edit an issue attachment */
        patch: operations["issueEditIssueAttachment"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/blocks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List issues that are blocked by this issue */
        get: operations["issueListBlocks"];
        put?: never;
        /** Block the issue given in the body by the issue in path */
        post: operations["issueCreateIssueBlocking"];
        /** Unblock the issue given in the body by the issue in path */
        delete: operations["issueRemoveIssueBlocking"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all comments on an issue */
        get: operations["issueGetComments"];
        put?: never;
        /** Add a comment to an issue */
        post: operations["issueCreateComment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/comments/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete a comment
         * @deprecated
         */
        delete: operations["issueDeleteCommentDeprecated"];
        options?: never;
        head?: never;
        /**
         * Edit a comment
         * @deprecated
         */
        patch: operations["issueEditCommentDeprecated"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/deadline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored. */
        post: operations["issueEditIssueDeadline"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/dependencies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an issue's dependencies, i.e all issues that block this issue. */
        get: operations["issueListIssueDependencies"];
        put?: never;
        /** Make the issue in the url depend on the issue in the form. */
        post: operations["issueCreateIssueDependencies"];
        /** Remove an issue dependency */
        delete: operations["issueRemoveIssueDependencies"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an issue's labels */
        get: operations["issueGetLabels"];
        /** Replace an issue's labels */
        put: operations["issueReplaceLabels"];
        /** Add a label to an issue */
        post: operations["issueAddLabel"];
        /** Remove all labels from an issue */
        delete: operations["issueClearLabels"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/labels/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Remove a label from an issue */
        delete: operations["issueRemoveLabel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/lock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Lock an issue */
        put: operations["issueLockIssue"];
        post?: never;
        /** Unlock an issue */
        delete: operations["issueUnlockIssue"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/pin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Pin an Issue */
        post: operations["pinIssue"];
        /** Unpin an Issue */
        delete: operations["unpinIssue"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/pin/{position}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Moves the Pin to the given Position */
        patch: operations["moveIssuePin"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/reactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a list reactions of an issue */
        get: operations["issueGetIssueReactions"];
        put?: never;
        /** Add a reaction to an issue */
        post: operations["issuePostIssueReaction"];
        /** Remove a reaction from an issue */
        delete: operations["issueDeleteIssueReaction"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/stopwatch/delete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete an issue's existing stopwatch. */
        delete: operations["issueDeleteStopWatch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/stopwatch/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Start stopwatch on an issue. */
        post: operations["issueStartStopWatch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/stopwatch/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Stop an issue's existing stopwatch. */
        post: operations["issueStopStopWatch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get users who subscribed on an issue. */
        get: operations["issueSubscriptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/subscriptions/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if user is subscribed to an issue */
        get: operations["issueCheckSubscription"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Subscribe user to issue */
        put: operations["issueAddSubscription"];
        post?: never;
        /** Unsubscribe user from issue */
        delete: operations["issueDeleteSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/timeline": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all comments and events on an issue */
        get: operations["issueGetCommentsAndTimeline"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/times": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List an issue's tracked times */
        get: operations["issueTrackedTimes"];
        put?: never;
        /** Add tracked time to a issue */
        post: operations["issueAddTime"];
        /** Reset a tracked time of an issue */
        delete: operations["issueResetTime"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/issues/{index}/times/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete specific tracked time */
        delete: operations["issueDeleteTime"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's keys */
        get: operations["repoListKeys"];
        put?: never;
        /** Add a key to a repository */
        post: operations["repoCreateKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/keys/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a repository's key by id */
        get: operations["repoGetKey"];
        put?: never;
        post?: never;
        /** Delete a key from a repository */
        delete: operations["repoDeleteKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all of a repository's labels */
        get: operations["issueListLabels"];
        put?: never;
        /** Create a label */
        post: operations["issueCreateLabel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/labels/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a single label */
        get: operations["issueGetLabel"];
        put?: never;
        post?: never;
        /** Delete a label */
        delete: operations["issueDeleteLabel"];
        options?: never;
        head?: never;
        /** Update a label */
        patch: operations["issueEditLabel"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/languages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get languages and number of bytes of code written */
        get: operations["repoGetLanguages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/licenses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get repo licenses */
        get: operations["repoGetLicenses"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/media/{filepath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a file or it's LFS object from a repository */
        get: operations["repoGetRawFileOrLFS"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/merge-upstream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Merge a branch from upstream */
        post: operations["repoMergeUpstream"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/milestones": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all of a repository's opened milestones */
        get: operations["issueGetMilestonesList"];
        put?: never;
        /** Create a milestone */
        post: operations["issueCreateMilestone"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/milestones/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a milestone */
        get: operations["issueGetMilestone"];
        put?: never;
        post?: never;
        /** Delete a milestone */
        delete: operations["issueDeleteMilestone"];
        options?: never;
        head?: never;
        /** Update a milestone */
        patch: operations["issueEditMilestone"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/mirror-sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Sync a mirrored repository */
        post: operations["repoMirrorSync"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/new_pin_allowed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns if new Issue Pins are allowed */
        get: operations["repoNewPinAllowed"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List users's notification threads on a specific repo */
        get: operations["notifyGetRepoList"];
        /** Mark notification threads as read, pinned or unread on a specific repo */
        put: operations["notifyReadRepoList"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's pull requests */
        get: operations["repoListPullRequests"];
        put?: never;
        /** Create a pull request */
        post: operations["repoCreatePullRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/pinned": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's pinned pull requests */
        get: operations["repoListPinnedPullRequests"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{base}/{head}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a pull request by base and head */
        get: operations["repoGetPullRequestByBaseHead"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a pull request */
        get: operations["repoGetPullRequest"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update a pull request. If using deadline only the date will be taken into account, and time of day ignored. */
        patch: operations["repoEditPullRequest"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}.{diffType}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a pull request diff or patch */
        get: operations["repoDownloadPullDiffOrPatch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/commits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get commits for a pull request */
        get: operations["repoGetPullRequestCommits"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get changed files for a pull request */
        get: operations["repoGetPullRequestFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/merge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a pull request has been merged */
        get: operations["repoPullRequestIsMerged"];
        put?: never;
        /** Merge a pull request */
        post: operations["repoMergePullRequest"];
        /** Cancel the scheduled auto merge for the given pull request */
        delete: operations["repoCancelScheduledAutoMerge"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/requested_reviewers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** create review requests for a pull request */
        post: operations["repoCreatePullReviewRequests"];
        /** cancel review requests for a pull request */
        delete: operations["repoDeletePullReviewRequests"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/reviews": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all reviews for a pull request */
        get: operations["repoListPullReviews"];
        put?: never;
        /** Create a review to an pull request */
        post: operations["repoCreatePullReview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a specific review for a pull request */
        get: operations["repoGetPullReview"];
        put?: never;
        /** Submit a pending review to an pull request */
        post: operations["repoSubmitPullReview"];
        /** Delete a specific review from a pull request */
        delete: operations["repoDeletePullReview"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a specific review for a pull request */
        get: operations["repoGetPullReviewComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Dismiss a review for a pull request */
        post: operations["repoDismissPullReview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Cancel to dismiss a review for a pull request */
        post: operations["repoUnDismissPullReview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/pulls/{index}/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Merge PR's baseBranch into headBranch */
        post: operations["repoUpdatePullRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/push_mirrors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all push mirrors of the repository */
        get: operations["repoListPushMirrors"];
        put?: never;
        /** add a push mirror to the repository */
        post: operations["repoAddPushMirror"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/push_mirrors-sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Sync all push mirrored repository */
        post: operations["repoPushMirrorSync"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/push_mirrors/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get push mirror of the repository by remoteName */
        get: operations["repoGetPushMirrorByRemoteName"];
        put?: never;
        post?: never;
        /** deletes a push mirror from a repository by remoteName */
        delete: operations["repoDeletePushMirror"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/raw/{filepath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a file from a repository */
        get: operations["repoGetRawFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/releases": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's releases */
        get: operations["repoListReleases"];
        put?: never;
        /** Create a release */
        post: operations["repoCreateRelease"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/releases/latest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at */
        get: operations["repoGetLatestRelease"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/releases/tags/{tag}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a release by tag name */
        get: operations["repoGetReleaseByTag"];
        put?: never;
        post?: never;
        /** Delete a release by tag name */
        delete: operations["repoDeleteReleaseByTag"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/releases/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a release */
        get: operations["repoGetRelease"];
        put?: never;
        post?: never;
        /** Delete a release */
        delete: operations["repoDeleteRelease"];
        options?: never;
        head?: never;
        /** Update a release */
        patch: operations["repoEditRelease"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/releases/{id}/assets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List release's attachments */
        get: operations["repoListReleaseAttachments"];
        put?: never;
        /** Create a release attachment */
        post: operations["repoCreateReleaseAttachment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a release attachment */
        get: operations["repoGetReleaseAttachment"];
        put?: never;
        post?: never;
        /** Delete a release attachment */
        delete: operations["repoDeleteReleaseAttachment"];
        options?: never;
        head?: never;
        /** Edit a release attachment */
        patch: operations["repoEditReleaseAttachment"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/reviewers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Return all users that can be requested to review in this repo */
        get: operations["repoGetReviewers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/signing-key.gpg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get signing-key.gpg for given repository */
        get: operations["repoSigningKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/signing-key.pub": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get signing-key.pub for given repository */
        get: operations["repoSigningKeySSH"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/stargazers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's stargazers */
        get: operations["repoListStargazers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/statuses/{sha}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a commit's statuses */
        get: operations["repoListStatuses"];
        put?: never;
        /** Create a commit status */
        post: operations["repoCreateStatus"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/subscribers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's watchers */
        get: operations["repoListSubscribers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/subscription": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if the current user is watching a repo */
        get: operations["userCurrentCheckSubscription"];
        /** Watch a repo */
        put: operations["userCurrentPutSubscription"];
        post?: never;
        /** Unwatch a repo */
        delete: operations["userCurrentDeleteSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/tag_protections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List tag protections for a repository */
        get: operations["repoListTagProtection"];
        put?: never;
        /** Create a tag protections for a repository */
        post: operations["repoCreateTagProtection"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/tag_protections/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a specific tag protection for the repository */
        get: operations["repoGetTagProtection"];
        put?: never;
        post?: never;
        /** Delete a specific tag protection for the repository */
        delete: operations["repoDeleteTagProtection"];
        options?: never;
        head?: never;
        /** Edit a tag protections for a repository. Only fields that are set will be changed */
        patch: operations["repoEditTagProtection"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's tags */
        get: operations["repoListTags"];
        put?: never;
        /** Create a new git tag in a repository */
        post: operations["repoCreateTag"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/tags/{tag}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the tag of a repository by tag name */
        get: operations["repoGetTag"];
        put?: never;
        post?: never;
        /** Delete a repository's tag by name */
        delete: operations["repoDeleteTag"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repository's teams */
        get: operations["repoListTeams"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/teams/{team}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a team is assigned to a repository */
        get: operations["repoCheckTeam"];
        /** Add a team to a repository */
        put: operations["repoAddTeam"];
        post?: never;
        /** Delete a team from a repository */
        delete: operations["repoDeleteTeam"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/times": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a repo's tracked times */
        get: operations["repoTrackedTimes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/times/{user}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a user's tracked times in a repo
         * @deprecated
         */
        get: operations["userTrackedTimes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/topics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of topics that a repository has */
        get: operations["repoListTopics"];
        /** Replace list of topics for a repository */
        put: operations["repoUpdateTopics"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/topics/{topic}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Add a topic to a repository */
        put: operations["repoAddTopic"];
        post?: never;
        /** Delete a topic from a repository */
        delete: operations["repoDeleteTopic"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/transfer": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Transfer a repo ownership */
        post: operations["repoTransfer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/transfer/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Accept a repo transfer */
        post: operations["acceptRepoTransfer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/transfer/reject": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reject a repo transfer */
        post: operations["rejectRepoTransfer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/wiki/new": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a wiki page */
        post: operations["repoCreateWikiPage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/wiki/page/{pageName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a wiki page */
        get: operations["repoGetWikiPage"];
        put?: never;
        post?: never;
        /** Delete a wiki page */
        delete: operations["repoDeleteWikiPage"];
        options?: never;
        head?: never;
        /** Edit a wiki page */
        patch: operations["repoEditWikiPage"];
        trace?: never;
    };
    "/repos/{owner}/{repo}/wiki/pages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all wiki pages */
        get: operations["repoGetWikiPages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{owner}/{repo}/wiki/revisions/{pageName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get revisions of a wiki page */
        get: operations["repoGetWikiPageRevisions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repos/{template_owner}/{template_repo}/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a repository using a template */
        post: operations["generateRepo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/repositories/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a repository by id */
        get: operations["repoGetByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/api": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance's global settings for api */
        get: operations["getGeneralAPISettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/attachment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance's global settings for Attachment */
        get: operations["getGeneralAttachmentSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/repository": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance's global settings for repositories */
        get: operations["getGeneralRepositorySettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/ui": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get instance's global settings for ui */
        get: operations["getGeneralUISettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signing-key.gpg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get default signing-key.gpg */
        get: operations["getSigningKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signing-key.pub": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get default signing-key.pub */
        get: operations["getSigningKeySSH"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a team */
        get: operations["orgGetTeam"];
        put?: never;
        post?: never;
        /** Delete a team */
        delete: operations["orgDeleteTeam"];
        options?: never;
        head?: never;
        /** Edit a team */
        patch: operations["orgEditTeam"];
        trace?: never;
    };
    "/teams/{id}/activities/feeds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a team's activity feeds */
        get: operations["orgListTeamActivityFeeds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a team's members */
        get: operations["orgListTeamMembers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/members/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a particular member of team */
        get: operations["orgListTeamMember"];
        /** Add a team member */
        put: operations["orgAddTeamMember"];
        post?: never;
        /** Remove a team member */
        delete: operations["orgRemoveTeamMember"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/repos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a team's repos */
        get: operations["orgListTeamRepos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/repos/{org}/{repo}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a particular repo of team */
        get: operations["orgListTeamRepo"];
        /** Add a repository to a team */
        put: operations["orgAddTeamRepository"];
        post?: never;
        /**
         * Remove a repository from a team
         * @description This does not delete the repository, it only removes the repository from the team.
         */
        delete: operations["orgRemoveTeamRepository"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/topics/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** search topics via keyword */
        get: operations["topicSearch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the authenticated user */
        get: operations["userGetCurrent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get workflow jobs */
        get: operations["getUserWorkflowJobs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/runners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get user-level runners */
        get: operations["getUserRunners"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/runners/registration-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an user's actions runner registration token */
        get: operations["userGetRunnerRegistrationToken"];
        put?: never;
        /** Get an user's actions runner registration token */
        post: operations["userCreateRunnerRegistrationToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/runners/{runner_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an user-level runner */
        get: operations["getUserRunner"];
        put?: never;
        post?: never;
        /** Delete an user-level runner */
        delete: operations["deleteUserRunner"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get workflow runs */
        get: operations["getUserWorkflowRuns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/secrets/{secretname}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Create or Update a secret value in a user scope */
        put: operations["updateUserSecret"];
        post?: never;
        /** Delete a secret in a user scope */
        delete: operations["deleteUserSecret"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/variables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the user-level list of variables which is created by current doer */
        get: operations["getUserVariablesList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/actions/variables/{variablename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a user-level variable which is created by current doer */
        get: operations["getUserVariable"];
        /** Update a user-level variable which is created by current doer */
        put: operations["updateUserVariable"];
        /** Create a user-level variable */
        post: operations["createUserVariable"];
        /** Delete a user-level variable which is created by current doer */
        delete: operations["deleteUserVariable"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/applications/oauth2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's oauth2 applications */
        get: operations["userGetOauth2Application"];
        put?: never;
        /** creates a new OAuth2 application */
        post: operations["userCreateOAuth2Application"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/applications/oauth2/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** get an OAuth2 Application */
        get: operations["userGetOAuth2Application"];
        put?: never;
        post?: never;
        /** delete an OAuth2 Application */
        delete: operations["userDeleteOAuth2Application"];
        options?: never;
        head?: never;
        /** update an OAuth2 Application, this includes regenerating the client secret */
        patch: operations["userUpdateOAuth2Application"];
        trace?: never;
    };
    "/user/avatar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update Avatar */
        post: operations["userUpdateAvatar"];
        /** Delete Avatar */
        delete: operations["userDeleteAvatar"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/blocks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List users blocked by the authenticated user */
        get: operations["userListBlocks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/blocks/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if a user is blocked by the authenticated user */
        get: operations["userCheckUserBlock"];
        /** Block a user */
        put: operations["userBlockUser"];
        post?: never;
        /** Unblock a user */
        delete: operations["userUnblockUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/emails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's email addresses */
        get: operations["userListEmails"];
        put?: never;
        /** Add email addresses */
        post: operations["userAddEmail"];
        /** Delete email addresses */
        delete: operations["userDeleteEmail"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/followers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's followers */
        get: operations["userCurrentListFollowers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/following": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the users that the authenticated user is following */
        get: operations["userCurrentListFollowing"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/following/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check whether a user is followed by the authenticated user */
        get: operations["userCurrentCheckFollowing"];
        /** Follow a user */
        put: operations["userCurrentPutFollow"];
        post?: never;
        /** Unfollow a user */
        delete: operations["userCurrentDeleteFollow"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/gpg_key_token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a Token to verify */
        get: operations["getVerificationToken"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/gpg_key_verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Verify a GPG key */
        post: operations["userVerifyGPGKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/gpg_keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's GPG keys */
        get: operations["userCurrentListGPGKeys"];
        put?: never;
        /** Create a GPG key */
        post: operations["userCurrentPostGPGKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/gpg_keys/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a GPG key */
        get: operations["userCurrentGetGPGKey"];
        put?: never;
        post?: never;
        /** Remove a GPG key */
        delete: operations["userCurrentDeleteGPGKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/hooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's webhooks */
        get: operations["userListHooks"];
        put?: never;
        /** Create a hook */
        post: operations["userCreateHook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/hooks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a hook */
        get: operations["userGetHook"];
        put?: never;
        post?: never;
        /** Delete a hook */
        delete: operations["userDeleteHook"];
        options?: never;
        head?: never;
        /** Update a hook */
        patch: operations["userEditHook"];
        trace?: never;
    };
    "/user/keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's public keys */
        get: operations["userCurrentListKeys"];
        put?: never;
        /** Create a public key */
        post: operations["userCurrentPostKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/keys/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a public key */
        get: operations["userCurrentGetKey"];
        put?: never;
        post?: never;
        /** Delete a public key */
        delete: operations["userCurrentDeleteKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/orgs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the current user's organizations */
        get: operations["orgListCurrentUserOrgs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/repos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the repos that the authenticated user owns */
        get: operations["userCurrentListRepos"];
        put?: never;
        /** Create a repository */
        post: operations["createCurrentUserRepo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get user settings */
        get: operations["getUserSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update user settings */
        patch: operations["updateUserSettings"];
        trace?: never;
    };
    "/user/starred": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** The repos that the authenticated user has starred */
        get: operations["userCurrentListStarred"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/starred/{owner}/{repo}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Whether the authenticated is starring the repo */
        get: operations["userCurrentCheckStarring"];
        /** Star the given repo */
        put: operations["userCurrentPutStar"];
        post?: never;
        /** Unstar the given repo */
        delete: operations["userCurrentDeleteStar"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/stopwatches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get list of all existing stopwatches */
        get: operations["userGetStopWatches"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List repositories watched by the authenticated user */
        get: operations["userCurrentListSubscriptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all the teams a user belongs to */
        get: operations["userListTeams"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/times": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the current user's tracked times */
        get: operations["userCurrentTrackedTimes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search for users */
        get: operations["userSearch"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a user */
        get: operations["userGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/activities/feeds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a user's activity feeds */
        get: operations["userListActivityFeeds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/followers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the given user's followers */
        get: operations["userListFollowers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/following": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the users that the given user is following */
        get: operations["userListFollowing"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/following/{target}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check if one user is following another user */
        get: operations["userCheckFollowing"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/gpg_keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the given user's GPG keys */
        get: operations["userListGPGKeys"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/heatmap": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a user's heatmap */
        get: operations["userGetHeatmapData"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the given user's public keys */
        get: operations["userListKeys"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/orgs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List a user's organizations */
        get: operations["orgListUserOrgs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/orgs/{org}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get user permissions in organization */
        get: operations["orgGetUserPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/repos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the repos owned by the given user */
        get: operations["userListRepos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/starred": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** The repos that the given user has starred */
        get: operations["userListStarred"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the repositories watched by a user */
        get: operations["userListSubscriptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List the authenticated user's access tokens */
        get: operations["userGetTokens"];
        put?: never;
        /** Create an access token */
        post: operations["userCreateToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/tokens/{token}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** delete an access token */
        delete: operations["userDeleteAccessToken"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns the version of the Gitea application */
        get: operations["getVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description APIError is an api error with a message */
        APIError: {
            /** @description Message contains the error description */
            message?: string;
            /** @description URL contains the documentation URL for this error */
            url?: string;
        };
        /** AccessToken represents an API access token. */
        AccessToken: {
            /**
             * Format: date-time
             * @description The timestamp when the token was created
             */
            created_at?: string;
            /**
             * Format: int64
             * @description The unique identifier of the access token
             */
            id?: number;
            /**
             * Format: date-time
             * @description The timestamp when the token was last used
             */
            last_used_at?: string;
            /** @description The name of the access token */
            name?: string;
            /** @description The scopes granted to this access token */
            scopes?: string[];
            /** @description The SHA1 hash of the access token */
            sha1?: string;
            /** @description The last eight characters of the token */
            token_last_eight?: string;
        };
        /** @description ActionArtifact represents a ActionArtifact */
        ActionArtifact: {
            archive_download_url?: string;
            /** Format: date-time */
            created_at?: string;
            expired?: boolean;
            /** Format: date-time */
            expires_at?: string;
            /** Format: int64 */
            id?: number;
            name?: string;
            /** Format: int64 */
            size_in_bytes?: number;
            /** Format: date-time */
            updated_at?: string;
            url?: string;
            workflow_run?: components["schemas"]["ActionWorkflowRun"];
        };
        /** @description ActionArtifactsResponse returns ActionArtifacts */
        ActionArtifactsResponse: {
            artifacts?: components["schemas"]["ActionArtifact"][];
            /** Format: int64 */
            total_count?: number;
        };
        /** @description ActionRunner represents a Runner */
        ActionRunner: {
            busy?: boolean;
            ephemeral?: boolean;
            /** Format: int64 */
            id?: number;
            labels?: components["schemas"]["ActionRunnerLabel"][];
            name?: string;
            status?: string;
        };
        /** @description ActionRunnerLabel represents a Runner Label */
        ActionRunnerLabel: {
            /** Format: int64 */
            id?: number;
            name?: string;
            type?: string;
        };
        /** @description ActionRunnersResponse returns Runners */
        ActionRunnersResponse: {
            runners?: components["schemas"]["ActionRunner"][];
            /** Format: int64 */
            total_count?: number;
        };
        /** @description ActionTask represents a ActionTask */
        ActionTask: {
            /** Format: date-time */
            created_at?: string;
            /** @description DisplayTitle is the display title for the workflow run */
            display_title?: string;
            /** @description Event is the type of event that triggered the workflow */
            event?: string;
            /** @description HeadBranch is the branch that triggered the workflow */
            head_branch?: string;
            /** @description HeadSHA is the commit SHA that triggered the workflow */
            head_sha?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the action task
             */
            id?: number;
            /** @description Name is the name of the workflow */
            name?: string;
            /**
             * Format: int64
             * @description RunNumber is the sequential number of the workflow run
             */
            run_number?: number;
            /** Format: date-time */
            run_started_at?: string;
            /** @description Status indicates the current status of the workflow run */
            status?: string;
            /** Format: date-time */
            updated_at?: string;
            /** @description URL is the API URL for this workflow run */
            url?: string;
            /** @description WorkflowID is the identifier of the workflow */
            workflow_id?: string;
        };
        /** @description ActionTaskResponse returns a ActionTask */
        ActionTaskResponse: {
            /**
             * Format: int64
             * @description TotalCount is the total number of workflow runs
             */
            total_count?: number;
            /** @description Entries contains the list of workflow runs */
            workflow_runs?: components["schemas"]["ActionTask"][];
        };
        /** @description ActionVariable return value of the query API */
        ActionVariable: {
            /** @description the value of the variable */
            data?: string;
            /** @description the description of the variable */
            description?: string;
            /** @description the name of the variable */
            name?: string;
            /**
             * Format: int64
             * @description the owner to which the variable belongs
             */
            owner_id?: number;
            /**
             * Format: int64
             * @description the repository to which the variable belongs
             */
            repo_id?: number;
        };
        /** @description ActionWorkflow represents a ActionWorkflow */
        ActionWorkflow: {
            /** @description BadgeURL is the URL for the workflow badge */
            badge_url?: string;
            /** Format: date-time */
            created_at?: string;
            /** Format: date-time */
            deleted_at?: string;
            /** @description HTMLURL is the web URL for viewing the workflow */
            html_url?: string;
            /** @description ID is the unique identifier for the workflow */
            id?: string;
            /** @description Name is the name of the workflow */
            name?: string;
            /** @description Path is the file path of the workflow */
            path?: string;
            /** @description State indicates if the workflow is active or disabled */
            state?: string;
            /** Format: date-time */
            updated_at?: string;
            /** @description URL is the API URL for this workflow */
            url?: string;
        };
        /** @description ActionWorkflowJob represents a WorkflowJob */
        ActionWorkflowJob: {
            /** Format: date-time */
            completed_at?: string;
            conclusion?: string;
            /** Format: date-time */
            created_at?: string;
            head_branch?: string;
            head_sha?: string;
            html_url?: string;
            /** Format: int64 */
            id?: number;
            labels?: string[];
            name?: string;
            /** Format: int64 */
            run_attempt?: number;
            /** Format: int64 */
            run_id?: number;
            run_url?: string;
            /** Format: int64 */
            runner_id?: number;
            runner_name?: string;
            /** Format: date-time */
            started_at?: string;
            status?: string;
            steps?: components["schemas"]["ActionWorkflowStep"][];
            url?: string;
        };
        /** @description ActionWorkflowJobsResponse returns ActionWorkflowJobs */
        ActionWorkflowJobsResponse: {
            jobs?: components["schemas"]["ActionWorkflowJob"][];
            /** Format: int64 */
            total_count?: number;
        };
        /** @description ActionWorkflowResponse returns a ActionWorkflow */
        ActionWorkflowResponse: {
            /** Format: int64 */
            total_count?: number;
            workflows?: components["schemas"]["ActionWorkflow"][];
        };
        /** @description ActionWorkflowRun represents a WorkflowRun */
        ActionWorkflowRun: {
            actor?: components["schemas"]["User"];
            /** Format: date-time */
            completed_at?: string;
            conclusion?: string;
            display_title?: string;
            event?: string;
            head_branch?: string;
            head_repository?: components["schemas"]["Repository"];
            head_sha?: string;
            html_url?: string;
            /** Format: int64 */
            id?: number;
            path?: string;
            repository?: components["schemas"]["Repository"];
            /** Format: int64 */
            repository_id?: number;
            /** Format: int64 */
            run_attempt?: number;
            /** Format: int64 */
            run_number?: number;
            /** Format: date-time */
            started_at?: string;
            status?: string;
            trigger_actor?: components["schemas"]["User"];
            url?: string;
        };
        /** @description ActionWorkflowRunsResponse returns ActionWorkflowRuns */
        ActionWorkflowRunsResponse: {
            /** Format: int64 */
            total_count?: number;
            workflow_runs?: components["schemas"]["ActionWorkflowRun"][];
        };
        /** @description ActionWorkflowStep represents a step of a WorkflowJob */
        ActionWorkflowStep: {
            /** Format: date-time */
            completed_at?: string;
            conclusion?: string;
            name?: string;
            /** Format: int64 */
            number?: number;
            /** Format: date-time */
            started_at?: string;
            status?: string;
        };
        Activity: {
            act_user?: components["schemas"]["User"];
            /**
             * Format: int64
             * @description The ID of the user who performed the action
             */
            act_user_id?: number;
            comment?: components["schemas"]["Comment"];
            /**
             * Format: int64
             * @description The ID of the comment associated with the activity (if applicable)
             */
            comment_id?: number;
            /** @description Additional content or details about the activity */
            content?: string;
            /**
             * Format: date-time
             * @description The date and time when the activity occurred
             */
            created?: string;
            /**
             * Format: int64
             * @description The unique identifier of the activity
             */
            id?: number;
            /** @description Whether this activity is from a private repository */
            is_private?: boolean;
            /**
             * @description the type of action
             * @enum {string}
             */
            op_type?: "create_repo" | "rename_repo" | "star_repo" | "watch_repo" | "commit_repo" | "create_issue" | "create_pull_request" | "transfer_repo" | "push_tag" | "comment_issue" | "merge_pull_request" | "close_issue" | "reopen_issue" | "close_pull_request" | "reopen_pull_request" | "delete_tag" | "delete_branch" | "mirror_sync_push" | "mirror_sync_create" | "mirror_sync_delete" | "approve_pull_request" | "reject_pull_request" | "comment_pull" | "publish_release" | "pull_review_dismissed" | "pull_request_ready_for_review" | "auto_merge_pull_request";
            /** @description The name of the git reference (branch/tag) associated with the activity */
            ref_name?: string;
            repo?: components["schemas"]["Repository"];
            /**
             * Format: int64
             * @description The ID of the repository associated with the activity
             */
            repo_id?: number;
            /**
             * Format: int64
             * @description The ID of the user who receives/sees this activity
             */
            user_id?: number;
        };
        /** @description ActivityPub type */
        ActivityPub: {
            /** @description Context defines the JSON-LD context for ActivityPub */
            "@context"?: string;
        };
        /** @description AddCollaboratorOption options when adding a user as a collaborator of a repository */
        AddCollaboratorOption: {
            /** @enum {string} */
            permission?: "read" | "write" | "admin";
        };
        /** @description AddTimeOption options for adding time to an issue */
        AddTimeOption: {
            /** Format: date-time */
            created?: string;
            /**
             * Format: int64
             * @description time in seconds
             */
            time: number;
            /** @description username of the user who spent the time working on the issue (optional) */
            user_name?: string;
        };
        /** @description AnnotatedTag represents an annotated tag */
        AnnotatedTag: {
            /** @description The message associated with the annotated tag */
            message?: string;
            object?: components["schemas"]["AnnotatedTagObject"];
            /** @description The SHA hash of the annotated tag */
            sha?: string;
            /** @description The name of the annotated tag */
            tag?: string;
            tagger?: components["schemas"]["CommitUser"];
            /** @description The URL to access the annotated tag */
            url?: string;
            verification?: components["schemas"]["PayloadCommitVerification"];
        };
        /** @description AnnotatedTagObject contains meta information of the tag object */
        AnnotatedTagObject: {
            /** @description The SHA hash of the tagged object */
            sha?: string;
            /** @description The type of the tagged object (e.g., commit, tree) */
            type?: string;
            /** @description The URL to access the tagged object */
            url?: string;
        };
        /**
         * @description ApplyDiffPatchFileOptions options for applying a diff patch
         *     Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
         */
        ApplyDiffPatchFileOptions: {
            author?: components["schemas"]["Identity"];
            /** @description branch (optional) to base this file from. if not given, the default branch is used */
            branch?: string;
            committer?: components["schemas"]["Identity"];
            content: string;
            dates?: components["schemas"]["CommitDateOptions"];
            /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
            message?: string;
            /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
            new_branch?: string;
            /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
            signoff?: boolean;
        };
        /** @description Attachment a generic attachment */
        Attachment: {
            /** @description DownloadURL is the URL to download the attachment */
            browser_download_url?: string;
            /** Format: date-time */
            created_at?: string;
            /**
             * Format: int64
             * @description DownloadCount is the number of times the attachment has been downloaded
             */
            download_count?: number;
            /**
             * Format: int64
             * @description ID is the unique identifier for the attachment
             */
            id?: number;
            /** @description Name is the filename of the attachment */
            name?: string;
            /**
             * Format: int64
             * @description Size is the file size in bytes
             */
            size?: number;
            /** @description UUID is the unique identifier for the attachment file */
            uuid?: string;
        };
        /** @description Badge represents a user badge */
        Badge: {
            description?: string;
            /** Format: int64 */
            id?: number;
            image_url?: string;
            slug?: string;
        };
        /** @description Branch represents a repository branch */
        Branch: {
            commit?: components["schemas"]["PayloadCommit"];
            /** @description EffectiveBranchProtectionName is the name of the effective branch protection rule */
            effective_branch_protection_name?: string;
            /** @description EnableStatusCheck indicates if status checks are enabled */
            enable_status_check?: boolean;
            /** @description Name is the branch name */
            name?: string;
            /** @description Protected indicates if the branch is protected */
            protected?: boolean;
            /**
             * Format: int64
             * @description RequiredApprovals is the number of required approvals for pull requests
             */
            required_approvals?: number;
            /** @description StatusCheckContexts contains the list of required status check contexts */
            status_check_contexts?: string[];
            /** @description UserCanMerge indicates if the current user can merge to this branch */
            user_can_merge?: boolean;
            /** @description UserCanPush indicates if the current user can push to this branch */
            user_can_push?: boolean;
        };
        /** @description BranchProtection represents a branch protection for a repository */
        BranchProtection: {
            approvals_whitelist_teams?: string[];
            approvals_whitelist_username?: string[];
            block_admin_merge_override?: boolean;
            block_on_official_review_requests?: boolean;
            block_on_outdated_branch?: boolean;
            block_on_rejected_reviews?: boolean;
            /** @description Deprecated: true */
            branch_name?: string;
            /** Format: date-time */
            created_at?: string;
            dismiss_stale_approvals?: boolean;
            enable_approvals_whitelist?: boolean;
            enable_force_push?: boolean;
            enable_force_push_allowlist?: boolean;
            enable_merge_whitelist?: boolean;
            enable_push?: boolean;
            enable_push_whitelist?: boolean;
            enable_status_check?: boolean;
            force_push_allowlist_deploy_keys?: boolean;
            force_push_allowlist_teams?: string[];
            force_push_allowlist_usernames?: string[];
            ignore_stale_approvals?: boolean;
            merge_whitelist_teams?: string[];
            merge_whitelist_usernames?: string[];
            /**
             * Format: int64
             * @description Priority is the priority of this branch protection rule
             */
            priority?: number;
            protected_file_patterns?: string;
            push_whitelist_deploy_keys?: boolean;
            push_whitelist_teams?: string[];
            push_whitelist_usernames?: string[];
            require_signed_commits?: boolean;
            /** Format: int64 */
            required_approvals?: number;
            /** @description RuleName is the name of the branch protection rule */
            rule_name?: string;
            status_check_contexts?: string[];
            unprotected_file_patterns?: string;
            /** Format: date-time */
            updated_at?: string;
        };
        /** @description ChangeFileOperation for creating, updating or deleting a file */
        ChangeFileOperation: {
            /** @description new or updated file content, it must be base64 encoded */
            content?: string;
            /** @description old path of the file to move */
            from_path?: string;
            /**
             * @description indicates what to do with the file: "create" for creating a new file, "update" for updating an existing file,
             *     "upload" for creating or updating a file, "rename" for renaming a file, and "delete" for deleting an existing file.
             * @enum {string}
             */
            operation: "create" | "update" | "upload" | "rename" | "delete";
            /** @description path to the existing or new file */
            path: string;
            /** @description the blob ID (SHA) for the file that already exists, required for changing existing files */
            sha?: string;
        };
        /**
         * @description ChangeFilesOptions options for creating, updating or deleting multiple files
         *     Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
         */
        ChangeFilesOptions: {
            author?: components["schemas"]["Identity"];
            /** @description branch (optional) to base this file from. if not given, the default branch is used */
            branch?: string;
            committer?: components["schemas"]["Identity"];
            dates?: components["schemas"]["CommitDateOptions"];
            /** @description list of file operations */
            files: components["schemas"]["ChangeFileOperation"][];
            /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
            message?: string;
            /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
            new_branch?: string;
            /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
            signoff?: boolean;
        };
        /** @description ChangedFile store information about files affected by the pull request */
        ChangedFile: {
            /**
             * Format: int64
             * @description The number of lines added to the file
             */
            additions?: number;
            /**
             * Format: int64
             * @description The total number of changes to the file
             */
            changes?: number;
            /** @description The API URL to get the file contents */
            contents_url?: string;
            /**
             * Format: int64
             * @description The number of lines deleted from the file
             */
            deletions?: number;
            /** @description The name of the changed file */
            filename?: string;
            /** @description The HTML URL to view the file changes */
            html_url?: string;
            /** @description The previous filename if the file was renamed */
            previous_filename?: string;
            /** @description The raw URL to download the file */
            raw_url?: string;
            /** @description The status of the file change (added, modified, deleted, etc.) */
            status?: string;
        };
        /** @description CombinedStatus holds the combined state of several statuses for a single commit */
        CombinedStatus: {
            /** @description CommitURL is the API URL for the commit */
            commit_url?: string;
            repository?: components["schemas"]["Repository"];
            /** @description SHA is the commit SHA this status applies to */
            sha?: string;
            /**
             * @description State is the overall combined status state
             *     pending CommitStatusPending  CommitStatusPending is for when the CommitStatus is Pending
             *     success CommitStatusSuccess  CommitStatusSuccess is for when the CommitStatus is Success
             *     error CommitStatusError  CommitStatusError is for when the CommitStatus is Error
             *     failure CommitStatusFailure  CommitStatusFailure is for when the CommitStatus is Failure
             *     warning CommitStatusWarning  CommitStatusWarning is for when the CommitStatus is Warning
             *     skipped CommitStatusSkipped  CommitStatusSkipped is for when CommitStatus is Skipped
             * @enum {string}
             */
            state?: "pending" | "success" | "error" | "failure" | "warning" | "skipped";
            /** @description Statuses contains all individual commit statuses */
            statuses?: components["schemas"]["CommitStatus"][];
            /**
             * Format: int64
             * @description TotalCount is the total number of statuses
             */
            total_count?: number;
            /** @description URL is the API URL for this combined status */
            url?: string;
        };
        /** @description Comment represents a comment on a commit or issue */
        Comment: {
            /** @description Attachments contains files attached to the comment */
            assets?: components["schemas"]["Attachment"][];
            /** @description Body contains the comment text content */
            body?: string;
            /** Format: date-time */
            created_at?: string;
            /** @description HTMLURL is the web URL for viewing the comment */
            html_url?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the comment
             */
            id?: number;
            /** @description IssueURL is the API URL for the issue */
            issue_url?: string;
            /** @description OriginalAuthor is the original author name (for imported comments) */
            original_author?: string;
            /**
             * Format: int64
             * @description OriginalAuthorID is the original author ID (for imported comments)
             */
            original_author_id?: number;
            /** @description PRURL is the API URL for the pull request (if applicable) */
            pull_request_url?: string;
            /** Format: date-time */
            updated_at?: string;
            user?: components["schemas"]["User"];
        };
        /** Commit contains information generated from a Git commit. */
        Commit: {
            author?: components["schemas"]["User"];
            commit?: components["schemas"]["RepoCommit"];
            committer?: components["schemas"]["User"];
            /** Format: date-time */
            created?: string;
            /** @description Files contains information about files affected by the commit */
            files?: components["schemas"]["CommitAffectedFiles"][];
            /** @description HTMLURL is the web URL for viewing the commit */
            html_url?: string;
            /** @description Parents contains the parent commit information */
            parents?: components["schemas"]["CommitMeta"][];
            /** @description SHA is the commit SHA hash */
            sha?: string;
            stats?: components["schemas"]["CommitStats"];
            /** @description URL is the API URL for the commit */
            url?: string;
        };
        /** @description CommitAffectedFiles store information about files affected by the commit */
        CommitAffectedFiles: {
            /** @description Filename is the path of the affected file */
            filename?: string;
            /** @description Status indicates how the file was affected (added, modified, deleted) */
            status?: string;
        };
        /** @description CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE */
        CommitDateOptions: {
            /** Format: date-time */
            author?: string;
            /** Format: date-time */
            committer?: string;
        };
        /** CommitMeta contains meta information of a commit in terms of API. */
        CommitMeta: {
            /** Format: date-time */
            created?: string;
            /** @description SHA is the commit SHA hash */
            sha?: string;
            /** @description URL is the API URL for the commit */
            url?: string;
        };
        /** @description CommitStats is statistics for a RepoCommit */
        CommitStats: {
            /**
             * Format: int64
             * @description Additions is the number of lines added
             */
            additions?: number;
            /**
             * Format: int64
             * @description Deletions is the number of lines deleted
             */
            deletions?: number;
            /**
             * Format: int64
             * @description Total is the total number of lines changed
             */
            total?: number;
        };
        /** @description CommitStatus holds a single status of a single Commit */
        CommitStatus: {
            /** @description Context is the unique context identifier for the status */
            context?: string;
            /** Format: date-time */
            created_at?: string;
            creator?: components["schemas"]["User"];
            /** @description Description provides a brief description of the status */
            description?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the commit status
             */
            id?: number;
            /**
             * @description State represents the status state (pending, success, error, failure)
             *     pending CommitStatusPending  CommitStatusPending is for when the CommitStatus is Pending
             *     success CommitStatusSuccess  CommitStatusSuccess is for when the CommitStatus is Success
             *     error CommitStatusError  CommitStatusError is for when the CommitStatus is Error
             *     failure CommitStatusFailure  CommitStatusFailure is for when the CommitStatus is Failure
             *     warning CommitStatusWarning  CommitStatusWarning is for when the CommitStatus is Warning
             *     skipped CommitStatusSkipped  CommitStatusSkipped is for when CommitStatus is Skipped
             * @enum {string}
             */
            status?: "pending" | "success" | "error" | "failure" | "warning" | "skipped";
            /** @description TargetURL is the URL to link to for more details */
            target_url?: string;
            /** Format: date-time */
            updated_at?: string;
            /** @description URL is the API URL for this status */
            url?: string;
        };
        /** CommitUser contains information of a user in the context of a commit. */
        CommitUser: {
            /** @description Date is the commit date in string format */
            date?: string;
            /** Format: email */
            email?: string;
            /** @description Name is the person's name */
            name?: string;
        };
        /** Compare represents a comparison between two commits. */
        Compare: {
            commits?: components["schemas"]["Commit"][];
            /** Format: int64 */
            total_commits?: number;
        };
        ContentsExtResponse: {
            /** @description DirContents contains directory listing when the path represents a directory */
            dir_contents?: components["schemas"]["ContentsResponse"][];
            file_contents?: components["schemas"]["ContentsResponse"];
        };
        /** @description ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content */
        ContentsResponse: {
            _links?: components["schemas"]["FileLinksResponse"];
            /** @description `content` is populated when `type` is `file`, otherwise null */
            content?: string;
            /** @description DownloadURL is the direct download URL for this file */
            download_url?: string;
            /** @description `encoding` is populated when `type` is `file`, otherwise null */
            encoding?: string;
            /** @description GitURL is the Git API URL for this blob or tree */
            git_url?: string;
            /** @description HTMLURL is the web URL for this file or directory */
            html_url?: string;
            /** Format: date-time */
            last_author_date?: string;
            /** @description LastCommitMessage is the message of the last commit that affected this file */
            last_commit_message?: string;
            /** @description LastCommitSHA is the SHA of the last commit that affected this file */
            last_commit_sha?: string;
            /** Format: date-time */
            last_committer_date?: string;
            /** @description LfsOid is the Git LFS object ID if this file is stored in LFS */
            lfs_oid?: string;
            /**
             * Format: int64
             * @description LfsSize is the file size if this file is stored in LFS
             */
            lfs_size?: number;
            /** @description Name is the file or directory name */
            name?: string;
            /** @description Path is the full path to the file or directory */
            path?: string;
            /** @description SHA is the Git blob or tree SHA */
            sha?: string;
            /**
             * Format: int64
             * @description Size is the file size in bytes
             */
            size?: number;
            /** @description `submodule_git_url` is populated when `type` is `submodule`, otherwise null */
            submodule_git_url?: string;
            /** @description `target` is populated when `type` is `symlink`, otherwise null */
            target?: string;
            /** @description `type` will be `file`, `dir`, `symlink`, or `submodule` */
            type?: string;
            /** @description URL is the API URL for this file or directory */
            url?: string;
        };
        /** @description CreateAccessTokenOption options when create access token */
        CreateAccessTokenOption: {
            name: string;
            /**
             * @example [
             *       "all",
             *       "read:activitypub",
             *       "read:issue",
             *       "write:misc",
             *       "read:notification",
             *       "read:organization",
             *       "read:package",
             *       "read:repository",
             *       "read:user"
             *     ]
             */
            scopes?: string[];
        };
        /** @description CreateActionWorkflowDispatch represents the payload for triggering a workflow dispatch event */
        CreateActionWorkflowDispatch: {
            inputs?: {
                [key: string]: string;
            };
            /** @example refs/heads/main */
            ref: string;
        };
        /** @description CreateBranchProtectionOption options for creating a branch protection */
        CreateBranchProtectionOption: {
            approvals_whitelist_teams?: string[];
            approvals_whitelist_username?: string[];
            block_admin_merge_override?: boolean;
            block_on_official_review_requests?: boolean;
            block_on_outdated_branch?: boolean;
            block_on_rejected_reviews?: boolean;
            /** @description Deprecated: true */
            branch_name?: string;
            dismiss_stale_approvals?: boolean;
            enable_approvals_whitelist?: boolean;
            enable_force_push?: boolean;
            enable_force_push_allowlist?: boolean;
            enable_merge_whitelist?: boolean;
            enable_push?: boolean;
            enable_push_whitelist?: boolean;
            enable_status_check?: boolean;
            force_push_allowlist_deploy_keys?: boolean;
            force_push_allowlist_teams?: string[];
            force_push_allowlist_usernames?: string[];
            ignore_stale_approvals?: boolean;
            merge_whitelist_teams?: string[];
            merge_whitelist_usernames?: string[];
            /** Format: int64 */
            priority?: number;
            protected_file_patterns?: string;
            push_whitelist_deploy_keys?: boolean;
            push_whitelist_teams?: string[];
            push_whitelist_usernames?: string[];
            require_signed_commits?: boolean;
            /** Format: int64 */
            required_approvals?: number;
            rule_name?: string;
            status_check_contexts?: string[];
            unprotected_file_patterns?: string;
        };
        /** @description CreateBranchRepoOption options when creating a branch in a repository */
        CreateBranchRepoOption: {
            /** @description Name of the branch to create */
            new_branch_name: string;
            /**
             * @description Deprecated: true
             *     Name of the old branch to create from
             */
            old_branch_name?: string;
            /** @description Name of the old branch/tag/commit to create from */
            old_ref_name?: string;
        };
        /** @description CreateEmailOption options when creating email addresses */
        CreateEmailOption: {
            /** @description email addresses to add */
            emails?: string[];
        };
        /**
         * @description CreateFileOptions options for creating files
         *     Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
         */
        CreateFileOptions: {
            author?: components["schemas"]["Identity"];
            /** @description branch (optional) to base this file from. if not given, the default branch is used */
            branch?: string;
            committer?: components["schemas"]["Identity"];
            /** @description content must be base64 encoded */
            content: string;
            dates?: components["schemas"]["CommitDateOptions"];
            /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
            message?: string;
            /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
            new_branch?: string;
            /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
            signoff?: boolean;
        };
        /** @description CreateForkOption options for creating a fork */
        CreateForkOption: {
            /** @description name of the forked repository */
            name?: string;
            /** @description organization name, if forking into an organization */
            organization?: string;
        };
        /** @description CreateGPGKeyOption options create user GPG key */
        CreateGPGKeyOption: {
            /** @description An armored GPG key to add */
            armored_public_key: string;
            /** @description An optional armored signature for the GPG key */
            armored_signature?: string;
        };
        /** @description CreateHookOption options when create a hook */
        CreateHookOption: {
            /** @default false */
            active: boolean;
            /** @description Authorization header to include in webhook requests */
            authorization_header?: string;
            /** @description Branch filter pattern to determine which branches trigger the webhook */
            branch_filter?: string;
            config: components["schemas"]["CreateHookOptionConfig"];
            /** @description List of events that will trigger this webhook */
            events?: string[];
            /** @enum {string} */
            type: "dingtalk" | "discord" | "gitea" | "gogs" | "msteams" | "slack" | "telegram" | "feishu" | "wechatwork" | "packagist";
        };
        /**
         * @description CreateHookOptionConfig has all config options in it
         *     required are "content_type" and "url" Required
         */
        CreateHookOptionConfig: {
            [key: string]: string;
        };
        /** @description CreateIssueCommentOption options for creating a comment on an issue */
        CreateIssueCommentOption: {
            body: string;
        };
        /** @description CreateIssueOption options to create one issue */
        CreateIssueOption: {
            /** @description deprecated */
            assignee?: string;
            assignees?: string[];
            body?: string;
            closed?: boolean;
            /** Format: date-time */
            due_date?: string;
            /** @description list of label ids */
            labels?: number[];
            /**
             * Format: int64
             * @description milestone id
             */
            milestone?: number;
            ref?: string;
            title: string;
        };
        /** @description CreateKeyOption options when creating a key */
        CreateKeyOption: {
            /** @description An armored SSH key to add */
            key: string;
            /** @description Describe if the key has only read access or read/write */
            read_only?: boolean;
            /** @description Title of the key to add */
            title: string;
        };
        /** @description CreateLabelOption options for creating a label */
        CreateLabelOption: {
            /** @example #00aabb */
            color: string;
            /** @description Description provides additional context about the label's purpose */
            description?: string;
            /** @example false */
            exclusive?: boolean;
            /** @example false */
            is_archived?: boolean;
            name: string;
        };
        /** @description CreateMilestoneOption options for creating a milestone */
        CreateMilestoneOption: {
            /** @description Description provides details about the milestone */
            description?: string;
            /** Format: date-time */
            due_on?: string;
            /** @enum {string} */
            state?: "open" | "closed";
            /** @description Title is the title of the new milestone */
            title?: string;
        };
        /** @description CreateOAuth2ApplicationOptions holds options to create an oauth2 application */
        CreateOAuth2ApplicationOptions: {
            /** @description Whether the client is confidential */
            confidential_client?: boolean;
            /** @description The name of the OAuth2 application */
            name?: string;
            /** @description The list of allowed redirect URIs */
            redirect_uris?: string[];
            /** @description Whether to skip secondary authorization */
            skip_secondary_authorization?: boolean;
        };
        /** @description CreateOrUpdateSecretOption options when creating or updating secret */
        CreateOrUpdateSecretOption: {
            /** @description Data of the secret to update */
            data: string;
            /** @description Description of the secret to update */
            description?: string;
        };
        /** @description CreateOrgOption options for creating an organization */
        CreateOrgOption: {
            /** @description The description of the organization */
            description?: string;
            /** @description The email address of the organization */
            email?: string;
            /** @description The full display name of the organization */
            full_name?: string;
            /** @description The location of the organization */
            location?: string;
            /** @description Whether repository administrators can change team access */
            repo_admin_change_team_access?: boolean;
            /** @description username of the organization */
            username: string;
            /**
             * @description possible values are `public` (default), `limited` or `private`
             * @enum {string}
             */
            visibility?: "public" | "limited" | "private";
            /** @description The website URL of the organization */
            website?: string;
        };
        /** @description CreatePullRequestOption options when creating a pull request */
        CreatePullRequestOption: {
            /** @description The primary assignee username */
            assignee?: string;
            /** @description The list of assignee usernames */
            assignees?: string[];
            /** @description The base branch for the pull request */
            base?: string;
            /** @description The description body of the pull request */
            body?: string;
            /** Format: date-time */
            due_date?: string;
            /**
             * @description The head branch for the pull request, it could be a branch name on the base repository or
             *     a form like `<username>:<branch>` which refers to the user's fork repository's branch.
             */
            head?: string;
            /** @description The list of label IDs to assign to the pull request */
            labels?: number[];
            /**
             * Format: int64
             * @description The milestone ID to assign to the pull request
             */
            milestone?: number;
            /** @description The list of reviewer usernames */
            reviewers?: string[];
            /** @description The list of team reviewer names */
            team_reviewers?: string[];
            /** @description The title of the pull request */
            title?: string;
        };
        /** @description CreatePullReviewComment represent a review comment for creation api */
        CreatePullReviewComment: {
            body?: string;
            /**
             * Format: int64
             * @description if comment to new file line or 0
             */
            new_position?: number;
            /**
             * Format: int64
             * @description if comment to old file line or 0
             */
            old_position?: number;
            /** @description the tree path */
            path?: string;
        };
        /** @description CreatePullReviewOptions are options to create a pull review */
        CreatePullReviewOptions: {
            body?: string;
            comments?: components["schemas"]["CreatePullReviewComment"][];
            commit_id?: string;
            event?: components["schemas"]["ReviewStateType"];
        };
        /** CreatePushMirrorOption represents need information to create a push mirror of a repository. */
        CreatePushMirrorOption: {
            /** @description The sync interval for automatic updates */
            interval?: string;
            /** @description The remote repository URL to push to */
            remote_address?: string;
            /** @description The password for authentication with the remote repository */
            remote_password?: string;
            /** @description The username for authentication with the remote repository */
            remote_username?: string;
            /** @description Whether to sync on every commit */
            sync_on_commit?: boolean;
        };
        /** @description CreateReleaseOption options when creating a release */
        CreateReleaseOption: {
            /** @description The release notes or description */
            body?: string;
            /** @description Whether to create the release as a draft */
            draft?: boolean;
            /** @description The display title of the release */
            name?: string;
            /** @description Whether to mark the release as a prerelease */
            prerelease?: boolean;
            /** @description The message for the git tag */
            tag_message?: string;
            tag_name: string;
            /** @description The target commitish for the release */
            target_commitish?: string;
        };
        /** @description CreateRepoOption options when creating repository */
        CreateRepoOption: {
            /** @description Whether the repository should be auto-initialized? */
            auto_init?: boolean;
            /** @description DefaultBranch of the repository (used when initializes and in template) */
            default_branch?: string;
            /** @description Description of the repository to create */
            description?: string;
            /** @description Gitignores to use */
            gitignores?: string;
            /** @description Label-Set to use */
            issue_labels?: string;
            /** @description License to use */
            license?: string;
            /** @description Name of the repository to create */
            name: string;
            /**
             * @description ObjectFormatName of the underlying git repository
             * @enum {string}
             */
            object_format_name?: "sha1" | "sha256";
            /** @description Whether the repository is private */
            private?: boolean;
            /** @description Readme of the repository to create */
            readme?: string;
            /** @description Whether the repository is template */
            template?: boolean;
            /**
             * @description TrustModel of the repository
             * @enum {string}
             */
            trust_model?: "default" | "collaborator" | "committer" | "collaboratorcommitter";
        };
        /** @description CreateStatusOption holds the information needed to create a new CommitStatus for a Commit */
        CreateStatusOption: {
            /** @description Context is the unique context identifier for the status */
            context?: string;
            /** @description Description provides a brief description of the status */
            description?: string;
            /**
             * @description State represents the status state to set (pending, success, error, failure)
             *     pending CommitStatusPending  CommitStatusPending is for when the CommitStatus is Pending
             *     success CommitStatusSuccess  CommitStatusSuccess is for when the CommitStatus is Success
             *     error CommitStatusError  CommitStatusError is for when the CommitStatus is Error
             *     failure CommitStatusFailure  CommitStatusFailure is for when the CommitStatus is Failure
             *     warning CommitStatusWarning  CommitStatusWarning is for when the CommitStatus is Warning
             *     skipped CommitStatusSkipped  CommitStatusSkipped is for when CommitStatus is Skipped
             * @enum {string}
             */
            state?: "pending" | "success" | "error" | "failure" | "warning" | "skipped";
            /** @description TargetURL is the URL to link to for more details */
            target_url?: string;
        };
        /** @description CreateTagOption options when creating a tag */
        CreateTagOption: {
            /** @description The message to associate with the tag */
            message?: string;
            tag_name: string;
            /** @description The target commit SHA or branch name for the tag */
            target?: string;
        };
        /** @description CreateTagProtectionOption options for creating a tag protection */
        CreateTagProtectionOption: {
            /** @description The pattern to match tag names for protection */
            name_pattern?: string;
            /** @description List of team names allowed to create/delete protected tags */
            whitelist_teams?: string[];
            /** @description List of usernames allowed to create/delete protected tags */
            whitelist_usernames?: string[];
        };
        /** @description CreateTeamOption options for creating a team */
        CreateTeamOption: {
            /** @description Whether the team can create repositories in the organization */
            can_create_org_repo?: boolean;
            /** @description The description of the team */
            description?: string;
            /** @description Whether the team has access to all repositories in the organization */
            includes_all_repositories?: boolean;
            name: string;
            /** @enum {string} */
            permission?: "read" | "write" | "admin";
            /**
             * @example [
             *       "repo.actions",
             *       "repo.code",
             *       "repo.issues",
             *       "repo.ext_issues",
             *       "repo.wiki",
             *       "repo.ext_wiki",
             *       "repo.pulls",
             *       "repo.releases",
             *       "repo.projects",
             *       "repo.ext_wiki"
             *     ]
             */
            units?: string[];
            /** @example {"repo.actions","repo.packages","repo.code":"read","repo.issues":"write","repo.ext_issues":"none","repo.wiki":"admin","repo.pulls":"owner","repo.releases":"none","repo.projects":"none","repo.ext_wiki":"none"} */
            units_map?: {
                [key: string]: string;
            };
        };
        /** @description CreateUserOption create user options */
        CreateUserOption: {
            /**
             * Format: date-time
             * @description For explicitly setting the user creation timestamp. Useful when users are
             *     migrated from other systems. When omitted, the user's creation timestamp
             *     will be set to "now".
             */
            created_at?: string;
            /** Format: email */
            email: string;
            /** @description The full display name of the user */
            full_name?: string;
            /**
             * @description identifier of the user, provided by the external authenticator (if configured)
             * @default empty
             */
            login_name: string;
            /** @description Whether the user must change password on first login */
            must_change_password?: boolean;
            /** @description The plain text password for the user */
            password?: string;
            /** @description Whether the user has restricted access privileges */
            restricted?: boolean;
            /** @description Whether to send welcome notification email to the user */
            send_notify?: boolean;
            /**
             * Format: int64
             * @description The authentication source ID to associate with the user
             */
            source_id?: number;
            /** @description username of the user */
            username: string;
            /** @description User visibility level: public, limited, or private */
            visibility?: string;
        };
        /** @description CreateVariableOption the option when creating variable */
        CreateVariableOption: {
            /** @description Description of the variable to create */
            description?: string;
            /** @description Value of the variable to create */
            value: string;
        };
        /** @description CreateWikiPageOptions form for creating wiki */
        CreateWikiPageOptions: {
            /** @description content must be base64 encoded */
            content_base64?: string;
            /** @description optional commit message summarizing the change */
            message?: string;
            /** @description page title. leave empty to keep unchanged */
            title?: string;
        };
        /** @description Cron represents a Cron task */
        Cron: {
            /**
             * Format: int64
             * @description The total number of times this cron task has been executed
             */
            exec_times?: number;
            /** @description The name of the cron task */
            name?: string;
            /**
             * Format: date-time
             * @description The next scheduled execution time
             */
            next?: string;
            /**
             * Format: date-time
             * @description The previous execution time
             */
            prev?: string;
            /** @description The cron schedule expression (e.g., "0 0 * * *") */
            schedule?: string;
        };
        /** @description DeleteEmailOption options when deleting email addresses */
        DeleteEmailOption: {
            /** @description email addresses to delete */
            emails?: string[];
        };
        /**
         * @description DeleteFileOptions options for deleting files (used for other File structs below)
         *     Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
         */
        DeleteFileOptions: {
            author?: components["schemas"]["Identity"];
            /** @description branch (optional) to base this file from. if not given, the default branch is used */
            branch?: string;
            committer?: components["schemas"]["Identity"];
            dates?: components["schemas"]["CommitDateOptions"];
            /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
            message?: string;
            /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
            new_branch?: string;
            /** @description the blob ID (SHA) for the file that already exists, it is required for changing existing files */
            sha: string;
            /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
            signoff?: boolean;
        };
        /** @description DeployKey a deploy key */
        DeployKey: {
            /** Format: date-time */
            created_at?: string;
            /** @description Fingerprint is the key's fingerprint */
            fingerprint?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the deploy key
             */
            id?: number;
            /** @description Key contains the actual SSH key content */
            key?: string;
            /**
             * Format: int64
             * @description KeyID is the associated public key ID
             */
            key_id?: number;
            /** @description ReadOnly indicates if the key has read-only access */
            read_only?: boolean;
            repository?: components["schemas"]["Repository"];
            /** @description Title is the human-readable name for the key */
            title?: string;
            /** @description URL is the API URL for this deploy key */
            url?: string;
        };
        /** @description DismissPullReviewOptions are options to dismiss a pull review */
        DismissPullReviewOptions: {
            message?: string;
            priors?: boolean;
        };
        /** @description EditAttachmentOptions options for editing attachments */
        EditAttachmentOptions: {
            /** @description Name is the new filename for the attachment */
            name?: string;
        };
        /** @description EditBranchProtectionOption options for editing a branch protection */
        EditBranchProtectionOption: {
            approvals_whitelist_teams?: string[];
            approvals_whitelist_username?: string[];
            block_admin_merge_override?: boolean;
            block_on_official_review_requests?: boolean;
            block_on_outdated_branch?: boolean;
            block_on_rejected_reviews?: boolean;
            dismiss_stale_approvals?: boolean;
            enable_approvals_whitelist?: boolean;
            enable_force_push?: boolean;
            enable_force_push_allowlist?: boolean;
            enable_merge_whitelist?: boolean;
            enable_push?: boolean;
            enable_push_whitelist?: boolean;
            enable_status_check?: boolean;
            force_push_allowlist_deploy_keys?: boolean;
            force_push_allowlist_teams?: string[];
            force_push_allowlist_usernames?: string[];
            ignore_stale_approvals?: boolean;
            merge_whitelist_teams?: string[];
            merge_whitelist_usernames?: string[];
            /** Format: int64 */
            priority?: number;
            protected_file_patterns?: string;
            push_whitelist_deploy_keys?: boolean;
            push_whitelist_teams?: string[];
            push_whitelist_usernames?: string[];
            require_signed_commits?: boolean;
            /** Format: int64 */
            required_approvals?: number;
            status_check_contexts?: string[];
            unprotected_file_patterns?: string;
        };
        /** @description EditDeadlineOption options for creating a deadline */
        EditDeadlineOption: {
            /** Format: date-time */
            due_date: string;
        };
        /** @description EditGitHookOption options when modifying one Git hook */
        EditGitHookOption: {
            /** @description Content is the new script content for the hook */
            content?: string;
        };
        /** @description EditHookOption options when modify one hook */
        EditHookOption: {
            /** @description Whether the webhook is active and will be triggered */
            active?: boolean;
            /** @description Authorization header to include in webhook requests */
            authorization_header?: string;
            /** @description Branch filter pattern to determine which branches trigger the webhook */
            branch_filter?: string;
            /** @description Configuration settings for the webhook */
            config?: {
                [key: string]: string;
            };
            /** @description List of events that trigger this webhook */
            events?: string[];
        };
        /** @description EditIssueCommentOption options for editing a comment */
        EditIssueCommentOption: {
            body: string;
        };
        /** @description EditIssueOption options for editing an issue */
        EditIssueOption: {
            /** @description deprecated */
            assignee?: string;
            assignees?: string[];
            body?: string;
            /** Format: date-time */
            due_date?: string;
            /** Format: int64 */
            milestone?: number;
            ref?: string;
            state?: string;
            title?: string;
            unset_due_date?: boolean;
        };
        /** @description EditLabelOption options for editing a label */
        EditLabelOption: {
            /** @example #00aabb */
            color?: string;
            /** @description Description provides additional context about the label's purpose */
            description?: string;
            /** @example false */
            exclusive?: boolean;
            /** @example false */
            is_archived?: boolean;
            /** @description Name is the new display name for the label */
            name?: string;
        };
        /** @description EditMilestoneOption options for editing a milestone */
        EditMilestoneOption: {
            /** @description Description provides updated details about the milestone */
            description?: string;
            /**
             * Format: date-time
             * @description Deadline is the updated due date for the milestone
             */
            due_on?: string;
            /** @description State indicates the updated state of the milestone */
            state?: string;
            /** @description Title is the updated title of the milestone */
            title?: string;
        };
        /** @description EditOrgOption options for editing an organization */
        EditOrgOption: {
            /** @description The description of the organization */
            description?: string;
            /** @description The email address of the organization */
            email?: string;
            /** @description The full display name of the organization */
            full_name?: string;
            /** @description The location of the organization */
            location?: string;
            /** @description Whether repository administrators can change team access */
            repo_admin_change_team_access?: boolean;
            /**
             * @description possible values are `public`, `limited` or `private`
             * @enum {string}
             */
            visibility?: "public" | "limited" | "private";
            /** @description The website URL of the organization */
            website?: string;
        };
        /** @description EditPullRequestOption options when modify pull request */
        EditPullRequestOption: {
            /** @description Whether to allow maintainer edits */
            allow_maintainer_edit?: boolean;
            /** @description The new primary assignee username */
            assignee?: string;
            /** @description The new list of assignee usernames */
            assignees?: string[];
            /** @description The new base branch for the pull request */
            base?: string;
            /** @description The new description body for the pull request */
            body?: string;
            /** Format: date-time */
            due_date?: string;
            /** @description The new list of label IDs for the pull request */
            labels?: number[];
            /**
             * Format: int64
             * @description The new milestone ID for the pull request
             */
            milestone?: number;
            /** @description The new state for the pull request */
            state?: string;
            /** @description The new title for the pull request */
            title?: string;
            /** @description Whether to remove the current deadline */
            unset_due_date?: boolean;
        };
        /** @description EditReactionOption contain the reaction type */
        EditReactionOption: {
            /** @description The reaction content (e.g., emoji or reaction type) */
            content?: string;
        };
        /** @description EditReleaseOption options when editing a release */
        EditReleaseOption: {
            /** @description The new release notes or description */
            body?: string;
            /** @description Whether to change the draft status */
            draft?: boolean;
            /** @description The new display title of the release */
            name?: string;
            /** @description Whether to change the prerelease status */
            prerelease?: boolean;
            /** @description The new name of the git tag */
            tag_name?: string;
            /** @description The new target commitish for the release */
            target_commitish?: string;
        };
        /** @description EditRepoOption options when editing a repository's properties */
        EditRepoOption: {
            /** @description either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging. */
            allow_fast_forward_only_merge?: boolean;
            /** @description either `true` to allow mark pr as merged manually, or `false` to prevent it. */
            allow_manual_merge?: boolean;
            /** @description either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits. */
            allow_merge_commits?: boolean;
            /** @description either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging. */
            allow_rebase?: boolean;
            /** @description either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits. */
            allow_rebase_explicit?: boolean;
            /** @description either `true` to allow updating pull request branch by rebase, or `false` to prevent it. */
            allow_rebase_update?: boolean;
            /** @description either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging. */
            allow_squash_merge?: boolean;
            /** @description set to `true` to archive this repository. */
            archived?: boolean;
            /** @description either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur. */
            autodetect_manual_merge?: boolean;
            /** @description set to `true` to allow edits from maintainers by default */
            default_allow_maintainer_edit?: boolean;
            /** @description sets the default branch for this repository. */
            default_branch?: string;
            /** @description set to `true` to delete pr branch after merge by default */
            default_delete_branch_after_merge?: boolean;
            /** @description set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", or "fast-forward-only". */
            default_merge_style?: string;
            /** @description a short description of the repository. */
            description?: string;
            /** @description enable prune - remove obsolete remote-tracking references when mirroring */
            enable_prune?: boolean;
            external_tracker?: components["schemas"]["ExternalTracker"];
            external_wiki?: components["schemas"]["ExternalWiki"];
            /** @description either `true` to enable actions unit, or `false` to disable them. */
            has_actions?: boolean;
            /** @description either `true` to enable code for this repository or `false` to disable it. */
            has_code?: boolean;
            /** @description either `true` to enable issues for this repository or `false` to disable them. */
            has_issues?: boolean;
            /** @description either `true` to enable packages unit, or `false` to disable them. */
            has_packages?: boolean;
            /** @description either `true` to enable project unit, or `false` to disable them. */
            has_projects?: boolean;
            /** @description either `true` to allow pull requests, or `false` to prevent pull request. */
            has_pull_requests?: boolean;
            /** @description either `true` to enable releases unit, or `false` to disable them. */
            has_releases?: boolean;
            /** @description either `true` to enable the wiki for this repository or `false` to disable it. */
            has_wiki?: boolean;
            /** @description either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace. */
            ignore_whitespace_conflicts?: boolean;
            internal_tracker?: components["schemas"]["InternalTracker"];
            /** @description set to a string like `8h30m0s` to set the mirror interval time */
            mirror_interval?: string;
            /** @description name of the repository */
            name?: string;
            /**
             * @description either `true` to make the repository private or `false` to make it public.
             *     Note: you will get a 422 error if the organization restricts changing repository visibility to organization
             *     owners and a non-owner tries to change the value of private.
             */
            private?: boolean;
            /** @description `repo` to only allow repo-level projects, `owner` to only allow owner projects, `all` to allow both. */
            projects_mode?: string;
            /** @description either `true` to make this repository a template or `false` to make it a normal repository */
            template?: boolean;
            /** @description a URL with more information about the repository. */
            website?: string;
        };
        /** @description EditTagProtectionOption options for editing a tag protection */
        EditTagProtectionOption: {
            /** @description The pattern to match tag names for protection */
            name_pattern?: string;
            /** @description List of team names allowed to create/delete protected tags */
            whitelist_teams?: string[];
            /** @description List of usernames allowed to create/delete protected tags */
            whitelist_usernames?: string[];
        };
        /** @description EditTeamOption options for editing a team */
        EditTeamOption: {
            /** @description Whether the team can create repositories in the organization */
            can_create_org_repo?: boolean;
            /** @description The description of the team */
            description?: string;
            /** @description Whether the team has access to all repositories in the organization */
            includes_all_repositories?: boolean;
            name: string;
            /** @enum {string} */
            permission?: "read" | "write" | "admin";
            /**
             * @example [
             *       "repo.code",
             *       "repo.issues",
             *       "repo.ext_issues",
             *       "repo.wiki",
             *       "repo.pulls",
             *       "repo.releases",
             *       "repo.projects",
             *       "repo.ext_wiki"
             *     ]
             */
            units?: string[];
            /**
             * @example {
             *       "repo.code": "read",
             *       "repo.ext_issues": "none",
             *       "repo.ext_wiki": "none",
             *       "repo.issues": "write",
             *       "repo.projects": "none",
             *       "repo.pulls": "owner",
             *       "repo.releases": "none",
             *       "repo.wiki": "admin"
             *     }
             */
            units_map?: {
                [key: string]: string;
            };
        };
        /** @description EditUserOption edit user options */
        EditUserOption: {
            /** @description Whether the user account is active */
            active?: boolean;
            /** @description Whether the user has administrator privileges */
            admin?: boolean;
            /** @description Whether the user can create organizations */
            allow_create_organization?: boolean;
            /** @description Whether the user can use Git hooks */
            allow_git_hook?: boolean;
            /** @description Whether the user can import local repositories */
            allow_import_local?: boolean;
            /** @description The user's personal description or bio */
            description?: string;
            /** Format: email */
            email?: string;
            /** @description The full display name of the user */
            full_name?: string;
            /** @description The user's location or address */
            location?: string;
            /**
             * @description identifier of the user, provided by the external authenticator (if configured)
             * @default empty
             */
            login_name: string;
            /**
             * Format: int64
             * @description Maximum number of repositories the user can create
             */
            max_repo_creation?: number;
            /** @description Whether the user must change password on next login */
            must_change_password?: boolean;
            /** @description The plain text password for the user */
            password?: string;
            /** @description Whether the user is prohibited from logging in */
            prohibit_login?: boolean;
            /** @description Whether the user has restricted access privileges */
            restricted?: boolean;
            /** Format: int64 */
            source_id: number;
            /** @description User visibility level: public, limited, or private */
            visibility?: string;
            /** @description The user's personal website URL */
            website?: string;
        };
        /** @description Email an email address belonging to a user */
        Email: {
            /** Format: email */
            email?: string;
            /** @description Whether this is the primary email address */
            primary?: boolean;
            /**
             * Format: int64
             * @description The unique identifier of the user who owns this email
             */
            user_id?: number;
            /** @description username of the user */
            username?: string;
            /** @description Whether the email address has been verified */
            verified?: boolean;
        };
        /** @description ExternalTracker represents settings for external tracker */
        ExternalTracker: {
            /** @description External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index. */
            external_tracker_format?: string;
            /** @description External Issue Tracker issue regular expression */
            external_tracker_regexp_pattern?: string;
            /** @description External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp` */
            external_tracker_style?: string;
            /** @description URL of external issue tracker. */
            external_tracker_url?: string;
        };
        /** @description ExternalWiki represents setting for external wiki */
        ExternalWiki: {
            /** @description URL of external wiki. */
            external_wiki_url?: string;
        };
        /** FileCommitResponse contains information generated from a Git commit for a repo's file. */
        FileCommitResponse: {
            author?: components["schemas"]["CommitUser"];
            committer?: components["schemas"]["CommitUser"];
            /** Format: date-time */
            created?: string;
            /** @description HTMLURL is the web URL for viewing this commit */
            html_url?: string;
            /** @description Message is the commit message */
            message?: string;
            /** @description Parents contains parent commit metadata */
            parents?: components["schemas"]["CommitMeta"][];
            /** @description SHA is the commit SHA hash */
            sha?: string;
            tree?: components["schemas"]["CommitMeta"];
            /** @description URL is the API URL for the commit */
            url?: string;
        };
        /** @description FileDeleteResponse contains information about a repo's file that was deleted */
        FileDeleteResponse: {
            commit?: components["schemas"]["FileCommitResponse"];
            /** @description Content is always null for delete operations */
            content?: unknown;
            verification?: components["schemas"]["PayloadCommitVerification"];
        };
        /** @description FileLinksResponse contains the links for a repo's file */
        FileLinksResponse: {
            /** @description GitURL is the Git API URL for this file */
            git?: string;
            /** @description HTMLURL is the web URL for this file */
            html?: string;
            /** @description Self is the API URL for this file */
            self?: string;
        };
        /** @description FileResponse contains information about a repo's file */
        FileResponse: {
            commit?: components["schemas"]["FileCommitResponse"];
            content?: components["schemas"]["ContentsResponse"];
            verification?: components["schemas"]["PayloadCommitVerification"];
        };
        /** @description FilesResponse contains information about multiple files from a repo */
        FilesResponse: {
            commit?: components["schemas"]["FileCommitResponse"];
            /** @description Files contains the list of file contents and metadata */
            files?: components["schemas"]["ContentsResponse"][];
            verification?: components["schemas"]["PayloadCommitVerification"];
        };
        /** @description GPGKey a user GPG key to sign commit and tag in repository */
        GPGKey: {
            /** @description Whether the key can be used for certification */
            can_certify?: boolean;
            /** @description Whether the key can be used for encrypting communications */
            can_encrypt_comms?: boolean;
            /** @description Whether the key can be used for encrypting storage */
            can_encrypt_storage?: boolean;
            /** @description Whether the key can be used for signing */
            can_sign?: boolean;
            /** Format: date-time */
            created_at?: string;
            /** @description List of email addresses associated with this GPG key */
            emails?: components["schemas"]["GPGKeyEmail"][];
            /** Format: date-time */
            expires_at?: string;
            /**
             * Format: int64
             * @description The unique identifier of the GPG key
             */
            id?: number;
            /** @description The key ID of the GPG key */
            key_id?: string;
            /** @description The primary key ID of the GPG key */
            primary_key_id?: string;
            /** @description The public key content in armored format */
            public_key?: string;
            /** @description List of subkeys of this GPG key */
            subkeys?: components["schemas"]["GPGKey"][];
            /** @description Whether the GPG key has been verified */
            verified?: boolean;
        };
        /** @description GPGKeyEmail an email attached to a GPGKey */
        GPGKeyEmail: {
            /** @description The email address associated with the GPG key */
            email?: string;
            /** @description Whether the email address has been verified */
            verified?: boolean;
        };
        /** @description GeneralAPISettings contains global api settings exposed by it */
        GeneralAPISettings: {
            /**
             * Format: int64
             * @description DefaultGitTreesPerPage is the default number of Git tree items per page
             */
            default_git_trees_per_page?: number;
            /**
             * Format: int64
             * @description DefaultMaxBlobSize is the default maximum blob size for API responses
             */
            default_max_blob_size?: number;
            /**
             * Format: int64
             * @description DefaultMaxResponseSize is the default maximum response size
             */
            default_max_response_size?: number;
            /**
             * Format: int64
             * @description DefaultPagingNum is the default number of items per page
             */
            default_paging_num?: number;
            /**
             * Format: int64
             * @description MaxResponseItems is the maximum number of items returned in API responses
             */
            max_response_items?: number;
        };
        /** @description GeneralAttachmentSettings contains global Attachment settings exposed by API */
        GeneralAttachmentSettings: {
            /** @description AllowedTypes contains the allowed file types for attachments */
            allowed_types?: string;
            /** @description Enabled indicates if file attachments are enabled */
            enabled?: boolean;
            /**
             * Format: int64
             * @description MaxFiles is the maximum number of files per attachment
             */
            max_files?: number;
            /**
             * Format: int64
             * @description MaxSize is the maximum size for individual attachments
             */
            max_size?: number;
        };
        /** @description GeneralRepoSettings contains global repository settings exposed by API */
        GeneralRepoSettings: {
            /** @description HTTPGitDisabled indicates if HTTP Git operations are disabled */
            http_git_disabled?: boolean;
            /** @description LFSDisabled indicates if Git LFS support is disabled */
            lfs_disabled?: boolean;
            /** @description MigrationsDisabled indicates if repository migrations are disabled */
            migrations_disabled?: boolean;
            /** @description MirrorsDisabled indicates if repository mirroring is disabled */
            mirrors_disabled?: boolean;
            /** @description StarsDisabled indicates if repository starring is disabled */
            stars_disabled?: boolean;
            /** @description TimeTrackingDisabled indicates if time tracking is disabled */
            time_tracking_disabled?: boolean;
        };
        /** @description GeneralUISettings contains global ui settings exposed by API */
        GeneralUISettings: {
            /** @description AllowedReactions contains the list of allowed emoji reactions */
            allowed_reactions?: string[];
            /** @description CustomEmojis contains the list of custom emojis */
            custom_emojis?: string[];
            /** @description DefaultTheme is the default UI theme */
            default_theme?: string;
        };
        /** @description GenerateRepoOption options when creating a repository using a template */
        GenerateRepoOption: {
            /** @description include avatar of the template repo */
            avatar?: boolean;
            /** @description Default branch of the new repository */
            default_branch?: string;
            /** @description Description of the repository to create */
            description?: string;
            /** @description include git content of default branch in template repo */
            git_content?: boolean;
            /** @description include git hooks in template repo */
            git_hooks?: boolean;
            /** @description include labels in template repo */
            labels?: boolean;
            name: string;
            /** @description the organization's name or individual user's name who will own the new repository */
            owner: string;
            /** @description Whether the repository is private */
            private?: boolean;
            /** @description include protected branches in template repo */
            protected_branch?: boolean;
            /** @description include topics in template repo */
            topics?: boolean;
            /** @description include webhooks in template repo */
            webhooks?: boolean;
        };
        /** @description GetFilesOptions options for retrieving metadate and content of multiple files */
        GetFilesOptions: {
            /** @description Files is the list of file paths to retrieve */
            files?: string[];
        };
        /** @description GitBlobResponse represents a git blob */
        GitBlobResponse: {
            /** @description The content of the git blob (may be base64 encoded) */
            content?: string;
            /** @description The encoding used for the content (e.g., "base64") */
            encoding?: string;
            /** @description The LFS object ID if this blob is stored in LFS */
            lfs_oid?: string;
            /**
             * Format: int64
             * @description The size of the LFS object if this blob is stored in LFS
             */
            lfs_size?: number;
            /** @description The SHA hash of the git blob */
            sha?: string;
            /**
             * Format: int64
             * @description The size of the git blob in bytes
             */
            size?: number;
            /** @description The URL to access this git blob */
            url?: string;
        };
        /** @description GitEntry represents a git tree */
        GitEntry: {
            /** @description Mode is the file mode (permissions) */
            mode?: string;
            /** @description Path is the file or directory path */
            path?: string;
            /** @description SHA is the Git object SHA */
            sha?: string;
            /**
             * Format: int64
             * @description Size is the file size in bytes
             */
            size?: number;
            /** @description Type indicates if this is a file, directory, or symlink */
            type?: string;
            /** @description URL is the API URL for this tree entry */
            url?: string;
        };
        /** @description GitHook represents a Git repository hook */
        GitHook: {
            /** @description Content contains the script content of the hook */
            content?: string;
            /** @description IsActive indicates if the hook is active */
            is_active?: boolean;
            /** @description Name is the name of the Git hook */
            name?: string;
        };
        /** GitObject represents a Git object. */
        GitObject: {
            /** @description The SHA hash of the Git object */
            sha?: string;
            /** @description The type of the Git object (e.g., commit, tag, tree, blob) */
            type?: string;
            /** @description The URL to access this Git object */
            url?: string;
        };
        /** @description GitTreeResponse returns a git tree */
        GitTreeResponse: {
            /**
             * Format: int64
             * @description Page is the current page number for pagination
             */
            page?: number;
            /** @description SHA is the tree object SHA */
            sha?: string;
            /**
             * Format: int64
             * @description TotalCount is the total number of entries in the tree
             */
            total_count?: number;
            /** @description Entries contains the tree entries (files and directories) */
            tree?: components["schemas"]["GitEntry"][];
            /** @description Truncated indicates if the response was truncated due to size */
            truncated?: boolean;
            /** @description URL is the API URL for this tree */
            url?: string;
        };
        /** @description GitignoreTemplateInfo name and text of a gitignore template */
        GitignoreTemplateInfo: {
            /** @description Name is the name of the gitignore template */
            name?: string;
            /** @description Source contains the content of the gitignore template */
            source?: string;
        };
        /** @description Hook a hook is a web hook when one repository changed */
        Hook: {
            /** @description Whether the webhook is active and will be triggered */
            active?: boolean;
            /** @description Authorization header to include in webhook requests */
            authorization_header?: string;
            /** @description Branch filter pattern to determine which branches trigger the webhook */
            branch_filter?: string;
            /** @description Configuration settings for the webhook */
            config?: {
                [key: string]: string;
            };
            /** Format: date-time */
            created_at?: string;
            /** @description List of events that trigger this webhook */
            events?: string[];
            /**
             * Format: int64
             * @description The unique identifier of the webhook
             */
            id?: number;
            /** @description The type of the webhook (e.g., gitea, slack, discord) */
            type?: string;
            /** Format: date-time */
            updated_at?: string;
        };
        /** @description Identity for a person's identity like an author or committer */
        Identity: {
            /** Format: email */
            email?: string;
            /** @description Name is the person's name */
            name?: string;
        };
        /** @description InternalTracker represents settings for internal tracker */
        InternalTracker: {
            /** @description Let only contributors track time (Built-in issue tracker) */
            allow_only_contributors_to_track_time?: boolean;
            /** @description Enable dependencies for issues and pull requests (Built-in issue tracker) */
            enable_issue_dependencies?: boolean;
            /** @description Enable time tracking (Built-in issue tracker) */
            enable_time_tracker?: boolean;
        };
        /** @description Issue represents an issue in a repository */
        Issue: {
            assets?: components["schemas"]["Attachment"][];
            assignee?: components["schemas"]["User"];
            assignees?: components["schemas"]["User"][];
            body?: string;
            /** Format: date-time */
            closed_at?: string;
            /** Format: int64 */
            comments?: number;
            /** Format: date-time */
            created_at?: string;
            /** Format: date-time */
            due_date?: string;
            html_url?: string;
            /** Format: int64 */
            id?: number;
            is_locked?: boolean;
            labels?: components["schemas"]["Label"][];
            milestone?: components["schemas"]["Milestone"];
            /** Format: int64 */
            number?: number;
            original_author?: string;
            /** Format: int64 */
            original_author_id?: number;
            /** Format: int64 */
            pin_order?: number;
            pull_request?: components["schemas"]["PullRequestMeta"];
            ref?: string;
            repository?: components["schemas"]["RepositoryMeta"];
            state?: components["schemas"]["StateType"];
            /** Format: int64 */
            time_estimate?: number;
            title?: string;
            /** Format: date-time */
            updated_at?: string;
            url?: string;
            user?: components["schemas"]["User"];
        };
        IssueConfig: {
            blank_issues_enabled?: boolean;
            contact_links?: components["schemas"]["IssueConfigContactLink"][];
        };
        IssueConfigContactLink: {
            about?: string;
            name?: string;
            url?: string;
        };
        IssueConfigValidation: {
            message?: string;
            valid?: boolean;
        };
        /** @description IssueDeadline represents an issue deadline */
        IssueDeadline: {
            /** Format: date-time */
            due_date?: string;
        };
        /** @description IssueFormField represents a form field */
        IssueFormField: {
            attributes?: {
                [key: string]: unknown;
            };
            id?: string;
            type?: components["schemas"]["IssueFormFieldType"];
            validations?: {
                [key: string]: unknown;
            };
            visible?: components["schemas"]["IssueFormFieldVisible"][];
        };
        /** IssueFormFieldType defines issue form field type, can be "markdown", "textarea", "input", "dropdown" or "checkboxes" */
        IssueFormFieldType: string;
        /** @description IssueFormFieldVisible defines issue form field visible */
        IssueFormFieldVisible: string;
        /** @description IssueLabelsOption a collection of labels */
        IssueLabelsOption: {
            /**
             * @description Labels can be a list of integers representing label IDs
             *     or a list of strings representing label names
             */
            labels?: unknown[];
        };
        /** @description IssueMeta basic issue information */
        IssueMeta: {
            /** Format: int64 */
            index?: number;
            /** @description owner of the issue's repo */
            owner?: string;
            repo?: string;
        };
        /** @description IssueTemplate represents an issue template for a repository */
        IssueTemplate: {
            about?: string;
            assignees?: components["schemas"]["IssueTemplateStringSlice"];
            body?: components["schemas"]["IssueFormField"][];
            content?: string;
            file_name?: string;
            labels?: components["schemas"]["IssueTemplateStringSlice"];
            name?: string;
            ref?: string;
            title?: string;
        };
        IssueTemplateStringSlice: string[];
        /** @description Label a label to an issue or a pr */
        Label: {
            /** @example 00aabb */
            color?: string;
            /** @description Description provides additional context about the label's purpose */
            description?: string;
            /** @example false */
            exclusive?: boolean;
            /**
             * Format: int64
             * @description ID is the unique identifier for the label
             */
            id?: number;
            /** @example false */
            is_archived?: boolean;
            /** @description Name is the display name of the label */
            name?: string;
            /** @description URL is the API endpoint for accessing this label */
            url?: string;
        };
        /** @description LabelTemplate info of a Label template */
        LabelTemplate: {
            /** @example 00aabb */
            color?: string;
            /** @description Description provides additional context about the label template's purpose */
            description?: string;
            /** @example false */
            exclusive?: boolean;
            /** @description Name is the display name of the label template */
            name?: string;
        };
        /** @description LicensesInfo contains information about a License */
        LicenseTemplateInfo: {
            /** @description Body contains the full text of the license */
            body?: string;
            /** @description Implementation contains license implementation details */
            implementation?: string;
            /** @description Key is the unique identifier for the license template */
            key?: string;
            /** @description Name is the display name of the license */
            name?: string;
            /** @description URL is the reference URL for the license */
            url?: string;
        };
        /** @description LicensesListEntry is used for the API */
        LicensesTemplateListEntry: {
            /** @description Key is the unique identifier for the license template */
            key?: string;
            /** @description Name is the display name of the license */
            name?: string;
            /** @description URL is the reference URL for the license */
            url?: string;
        };
        /** @description LockIssueOption options to lock an issue */
        LockIssueOption: {
            lock_reason?: string;
        };
        /** @description MarkdownOption markdown options */
        MarkdownOption: {
            /**
             * @description URL path for rendering issue, media and file links
             *     Expected format: /subpath/{user}/{repo}/src/{branch, commit, tag}/{identifier/path}/{file/dir}
             *
             *     in: body
             */
            Context?: string;
            /**
             * @description Mode to render (markdown, comment, wiki, file)
             *
             *     in: body
             */
            Mode?: string;
            /**
             * @description Text markdown to render
             *
             *     in: body
             */
            Text?: string;
            /**
             * @description Is it a wiki page? (use mode=wiki instead)
             *
             *     Deprecated: true
             *     in: body
             */
            Wiki?: boolean;
        };
        /** @description MarkupOption markup options */
        MarkupOption: {
            /**
             * @description URL path for rendering issue, media and file links
             *     Expected format: /subpath/{user}/{repo}/src/{branch, commit, tag}/{identifier/path}/{file/dir}
             *
             *     in: body
             */
            Context?: string;
            /**
             * @description File path for detecting extension in file mode
             *
             *     in: body
             */
            FilePath?: string;
            /**
             * @description Mode to render (markdown, comment, wiki, file)
             *
             *     in: body
             */
            Mode?: string;
            /**
             * @description Text markup to render
             *
             *     in: body
             */
            Text?: string;
            /**
             * @description Is it a wiki page? (use mode=wiki instead)
             *
             *     Deprecated: true
             *     in: body
             */
            Wiki?: boolean;
        };
        /** @description MergePullRequestForm form for merging Pull Request */
        MergePullRequestOption: {
            /** @enum {string} */
            Do: "merge" | "rebase" | "rebase-merge" | "squash" | "fast-forward-only" | "manually-merged";
            MergeCommitID?: string;
            MergeMessageField?: string;
            MergeTitleField?: string;
            delete_branch_after_merge?: boolean;
            force_merge?: boolean;
            head_commit_id?: string;
            merge_when_checks_succeed?: boolean;
        };
        MergeUpstreamRequest: {
            branch?: string;
            ff_only?: boolean;
        };
        MergeUpstreamResponse: {
            merge_type?: string;
        };
        /**
         * @description MigrateRepoOptions options for migrating repository's
         *     this is used to interact with api v1
         */
        MigrateRepoOptions: {
            auth_password?: string;
            auth_token?: string;
            auth_username?: string;
            aws_access_key_id?: string;
            aws_secret_access_key?: string;
            clone_addr: string;
            description?: string;
            issues?: boolean;
            labels?: boolean;
            lfs?: boolean;
            lfs_endpoint?: string;
            milestones?: boolean;
            mirror?: boolean;
            mirror_interval?: string;
            private?: boolean;
            pull_requests?: boolean;
            releases?: boolean;
            repo_name: string;
            /** @description the organization's name or individual user's name who will own the migrated repository */
            repo_owner?: string;
            /** @enum {string} */
            service?: "git" | "github" | "gitea" | "gitlab" | "gogs" | "onedev" | "gitbucket" | "codebase" | "codecommit";
            /**
             * Format: int64
             * @description deprecated (only for backwards compatibility, use repo_owner instead)
             */
            uid?: number;
            wiki?: boolean;
        };
        /** @description Milestone milestone is a collection of issues on one repository */
        Milestone: {
            /** Format: date-time */
            closed_at?: string;
            /**
             * Format: int64
             * @description ClosedIssues is the number of closed issues in this milestone
             */
            closed_issues?: number;
            /** Format: date-time */
            created_at?: string;
            /** @description Description provides details about the milestone */
            description?: string;
            /** Format: date-time */
            due_on?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the milestone
             */
            id?: number;
            /**
             * Format: int64
             * @description OpenIssues is the number of open issues in this milestone
             */
            open_issues?: number;
            state?: components["schemas"]["StateType"];
            /** @description Title is the title of the milestone */
            title?: string;
            /** Format: date-time */
            updated_at?: string;
        };
        /** @description NewIssuePinsAllowed represents an API response that says if new Issue Pins are allowed */
        NewIssuePinsAllowed: {
            issues?: boolean;
            pull_requests?: boolean;
        };
        /** @description NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks */
        NodeInfo: {
            /** @description Metadata contains free form key value pairs for software specific values */
            metadata?: Record<string, never>;
            /** @description OpenRegistrations indicates if new user registrations are accepted */
            openRegistrations?: boolean;
            /** @description Protocols lists the protocols supported by this server */
            protocols?: string[];
            services?: components["schemas"]["NodeInfoServices"];
            software?: components["schemas"]["NodeInfoSoftware"];
            usage?: components["schemas"]["NodeInfoUsage"];
            /** @description Version specifies the schema version */
            version?: string;
        };
        /** @description NodeInfoServices contains the third party sites this server can connect to via their application API */
        NodeInfoServices: {
            /** @description Inbound lists services that can deliver content to this server */
            inbound?: string[];
            /** @description Outbound lists services this server can deliver content to */
            outbound?: string[];
        };
        /** @description NodeInfoSoftware contains Metadata about server software in use */
        NodeInfoSoftware: {
            /** @description Homepage is the URL to the homepage of this server software */
            homepage?: string;
            /** @description Name is the canonical name of this server software */
            name?: string;
            /** @description Repository is the URL to the source code repository */
            repository?: string;
            /** @description Version is the version of this server software */
            version?: string;
        };
        /** @description NodeInfoUsage contains usage statistics for this server */
        NodeInfoUsage: {
            /**
             * Format: int64
             * @description LocalComments is the total amount of comments made by users local to this server
             */
            localComments?: number;
            /**
             * Format: int64
             * @description LocalPosts is the total amount of posts made by users local to this server
             */
            localPosts?: number;
            users?: components["schemas"]["NodeInfoUsageUsers"];
        };
        /** @description NodeInfoUsageUsers contains statistics about the users of this server */
        NodeInfoUsageUsers: {
            /**
             * Format: int64
             * @description ActiveHalfyear is the amount of users that signed in at least once in the last 180 days
             */
            activeHalfyear?: number;
            /**
             * Format: int64
             * @description ActiveMonth is the amount of users that signed in at least once in the last 30 days
             */
            activeMonth?: number;
            /**
             * Format: int64
             * @description Total is the total amount of users on this server
             */
            total?: number;
        };
        /** @description Note contains information related to a git note */
        Note: {
            commit?: components["schemas"]["Commit"];
            /** @description The content message of the git note */
            message?: string;
        };
        /** @description NotificationCount number of unread notifications */
        NotificationCount: {
            /**
             * Format: int64
             * @description New is the number of unread notifications
             */
            new?: number;
        };
        /** @description NotificationSubject contains the notification subject (Issue/Pull/Commit) */
        NotificationSubject: {
            /** @description HTMLURL is the web URL for the notification subject */
            html_url?: string;
            /** @description LatestCommentHTMLURL is the web URL for the latest comment */
            latest_comment_html_url?: string;
            /** @description LatestCommentURL is the API URL for the latest comment */
            latest_comment_url?: string;
            state?: components["schemas"]["StateType"];
            /** @description Title is the title of the notification subject */
            title?: string;
            type?: components["schemas"]["NotifySubjectType"];
            /** @description URL is the API URL for the notification subject */
            url?: string;
        };
        /** @description NotificationThread expose Notification on API */
        NotificationThread: {
            /**
             * Format: int64
             * @description ID is the unique identifier for the notification thread
             */
            id?: number;
            /** @description Pinned indicates if the notification is pinned */
            pinned?: boolean;
            repository?: components["schemas"]["Repository"];
            subject?: components["schemas"]["NotificationSubject"];
            /** @description Unread indicates if the notification has been read */
            unread?: boolean;
            /**
             * Format: date-time
             * @description UpdatedAt is the time when the notification was last updated
             */
            updated_at?: string;
            /** @description URL is the API URL for this notification thread */
            url?: string;
        };
        /** @description NotifySubjectType represent type of notification subject */
        NotifySubjectType: string;
        /** OAuth2Application represents an OAuth2 application. */
        OAuth2Application: {
            /** @description The client ID of the OAuth2 application */
            client_id?: string;
            /** @description The client secret of the OAuth2 application */
            client_secret?: string;
            /** @description Whether the client is confidential */
            confidential_client?: boolean;
            /**
             * Format: date-time
             * @description The timestamp when the application was created
             */
            created?: string;
            /**
             * Format: int64
             * @description The unique identifier of the OAuth2 application
             */
            id?: number;
            /** @description The name of the OAuth2 application */
            name?: string;
            /** @description The list of allowed redirect URIs */
            redirect_uris?: string[];
            /** @description Whether to skip secondary authorization */
            skip_secondary_authorization?: boolean;
        };
        /** @description Organization represents an organization */
        Organization: {
            /** @description The URL of the organization's avatar */
            avatar_url?: string;
            /** @description The description of the organization */
            description?: string;
            /** @description The email address of the organization */
            email?: string;
            /** @description The full display name of the organization */
            full_name?: string;
            /**
             * Format: int64
             * @description The unique identifier of the organization
             */
            id?: number;
            /** @description The location of the organization */
            location?: string;
            /** @description The name of the organization */
            name?: string;
            /** @description Whether repository administrators can change team access */
            repo_admin_change_team_access?: boolean;
            /**
             * @description username of the organization
             *     deprecated
             */
            username?: string;
            /** @description The visibility level of the organization (public, limited, private) */
            visibility?: string;
            /** @description The website URL of the organization */
            website?: string;
        };
        /** @description OrganizationPermissions list different users permissions on an organization */
        OrganizationPermissions: {
            /** @description Whether the user can create repositories in the organization */
            can_create_repository?: boolean;
            /** @description Whether the user can read the organization */
            can_read?: boolean;
            /** @description Whether the user can write to the organization */
            can_write?: boolean;
            /** @description Whether the user is an admin of the organization */
            is_admin?: boolean;
            /** @description Whether the user is an owner of the organization */
            is_owner?: boolean;
        };
        /** @description PRBranchInfo information about a branch */
        PRBranchInfo: {
            /** @description The display name of the branch */
            label?: string;
            /** @description The git reference of the branch */
            ref?: string;
            repo?: components["schemas"]["Repository"];
            /**
             * Format: int64
             * @description The unique identifier of the repository
             */
            repo_id?: number;
            /** @description The commit SHA of the branch head */
            sha?: string;
        };
        /** @description Package represents a package */
        Package: {
            /** Format: date-time */
            created_at?: string;
            creator?: components["schemas"]["User"];
            /** @description The HTML URL to view the package */
            html_url?: string;
            /**
             * Format: int64
             * @description The unique identifier of the package
             */
            id?: number;
            /** @description The name of the package */
            name?: string;
            owner?: components["schemas"]["User"];
            repository?: components["schemas"]["Repository"];
            /** @description The type of the package (e.g., npm, maven, docker) */
            type?: string;
            /** @description The version of the package */
            version?: string;
        };
        /** @description PackageFile represents a package file */
        PackageFile: {
            /**
             * Format: int64
             * @description The unique identifier of the package file
             */
            id?: number;
            /** @description The MD5 hash of the package file */
            md5?: string;
            /** @description The name of the package file */
            name?: string;
            /** @description The SHA1 hash of the package file */
            sha1?: string;
            /** @description The SHA256 hash of the package file */
            sha256?: string;
            /** @description The SHA512 hash of the package file */
            sha512?: string;
            /**
             * Format: int64
             * @description The size of the package file in bytes
             */
            size?: number;
        };
        /** @description PayloadCommit represents a commit */
        PayloadCommit: {
            /** @description List of files added in this commit */
            added?: string[];
            author?: components["schemas"]["PayloadUser"];
            committer?: components["schemas"]["PayloadUser"];
            /** @description sha1 hash of the commit */
            id?: string;
            /** @description The commit message */
            message?: string;
            /** @description List of files modified in this commit */
            modified?: string[];
            /** @description List of files removed in this commit */
            removed?: string[];
            /** Format: date-time */
            timestamp?: string;
            /** @description The URL to view this commit */
            url?: string;
            verification?: components["schemas"]["PayloadCommitVerification"];
        };
        /** @description PayloadCommitVerification represents the GPG verification of a commit */
        PayloadCommitVerification: {
            /** @description The signed payload content */
            payload?: string;
            /** @description The reason for the verification status */
            reason?: string;
            /** @description The GPG signature of the commit */
            signature?: string;
            signer?: components["schemas"]["PayloadUser"];
            /** @description Whether the commit signature is verified */
            verified?: boolean;
        };
        /** @description PayloadUser represents the author or committer of a commit */
        PayloadUser: {
            /** Format: email */
            email?: string;
            /** @description Full name of the commit author */
            name?: string;
            /** @description username of the user */
            username?: string;
        };
        /** @description Permission represents a set of permissions */
        Permission: {
            admin?: boolean;
            pull?: boolean;
            push?: boolean;
        };
        /** @description PublicKey publickey is a user key to push code to repository */
        PublicKey: {
            /** Format: date-time */
            created_at?: string;
            /** @description Fingerprint is the key's fingerprint */
            fingerprint?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the public key
             */
            id?: number;
            /** @description Key contains the actual SSH public key content */
            key?: string;
            /** @description KeyType indicates the type of the SSH key */
            key_type?: string;
            /**
             * Format: date-time
             * @description Updated is the time when the key was last used
             */
            last_used_at?: string;
            /** @description ReadOnly indicates if the key has read-only access */
            read_only?: boolean;
            /** @description Title is the human-readable name for the key */
            title?: string;
            /** @description URL is the API URL for this key */
            url?: string;
            user?: components["schemas"]["User"];
        };
        /** @description PullRequest represents a pull request */
        PullRequest: {
            /**
             * Format: int64
             * @description The number of lines added in the pull request
             */
            additions?: number;
            /** @description Whether maintainers can edit the pull request */
            allow_maintainer_edit?: boolean;
            assignee?: components["schemas"]["User"];
            /** @description The list of users assigned to the pull request */
            assignees?: components["schemas"]["User"][];
            base?: components["schemas"]["PRBranchInfo"];
            /** @description The description body of the pull request */
            body?: string;
            /**
             * Format: int64
             * @description The number of files changed in the pull request
             */
            changed_files?: number;
            /** Format: date-time */
            closed_at?: string;
            /**
             * Format: int64
             * @description The number of comments on the pull request
             */
            comments?: number;
            /** Format: date-time */
            created_at?: string;
            /**
             * Format: int64
             * @description The number of lines deleted in the pull request
             */
            deletions?: number;
            /** @description The URL to download the diff patch */
            diff_url?: string;
            /** @description Whether the pull request is a draft */
            draft?: boolean;
            /** Format: date-time */
            due_date?: string;
            head?: components["schemas"]["PRBranchInfo"];
            /** @description The HTML URL to view the pull request */
            html_url?: string;
            /**
             * Format: int64
             * @description The unique identifier of the pull request
             */
            id?: number;
            /** @description Whether the pull request conversation is locked */
            is_locked?: boolean;
            /** @description The labels attached to the pull request */
            labels?: components["schemas"]["Label"][];
            /** @description The merge base commit SHA */
            merge_base?: string;
            /** @description The SHA of the merge commit */
            merge_commit_sha?: string;
            /** @description Whether the pull request can be merged */
            mergeable?: boolean;
            /** @description Whether the pull request has been merged */
            merged?: boolean;
            /** Format: date-time */
            merged_at?: string;
            merged_by?: components["schemas"]["User"];
            milestone?: components["schemas"]["Milestone"];
            /**
             * Format: int64
             * @description The pull request number
             */
            number?: number;
            /** @description The URL to download the patch file */
            patch_url?: string;
            /**
             * Format: int64
             * @description The pin order for the pull request
             */
            pin_order?: number;
            /** @description The users requested to review the pull request */
            requested_reviewers?: components["schemas"]["User"][];
            /** @description The teams requested to review the pull request */
            requested_reviewers_teams?: components["schemas"]["Team"][];
            /**
             * Format: int64
             * @description number of review comments made on the diff of a PR review (not including comments on commits or issues in a PR)
             */
            review_comments?: number;
            state?: components["schemas"]["StateType"];
            /** @description The title of the pull request */
            title?: string;
            /** Format: date-time */
            updated_at?: string;
            /** @description The API URL of the pull request */
            url?: string;
            user?: components["schemas"]["User"];
        };
        /** @description PullRequestMeta PR info if an issue is a PR */
        PullRequestMeta: {
            draft?: boolean;
            html_url?: string;
            merged?: boolean;
            /** Format: date-time */
            merged_at?: string;
        };
        /** @description PullReview represents a pull request review */
        PullReview: {
            body?: string;
            /** Format: int64 */
            comments_count?: number;
            commit_id?: string;
            dismissed?: boolean;
            /** @description HTMLURL is the web URL for viewing the review */
            html_url?: string;
            /** Format: int64 */
            id?: number;
            official?: boolean;
            /** @description HTMLPullURL is the web URL for the pull request */
            pull_request_url?: string;
            stale?: boolean;
            state?: components["schemas"]["ReviewStateType"];
            /** Format: date-time */
            submitted_at?: string;
            team?: components["schemas"]["Team"];
            /** Format: date-time */
            updated_at?: string;
            user?: components["schemas"]["User"];
        };
        /** @description PullReviewComment represents a comment on a pull request review */
        PullReviewComment: {
            body?: string;
            commit_id?: string;
            /** Format: date-time */
            created_at?: string;
            diff_hunk?: string;
            html_url?: string;
            /** Format: int64 */
            id?: number;
            original_commit_id?: string;
            /** Format: uint64 */
            original_position?: number;
            path?: string;
            /** Format: uint64 */
            position?: number;
            /** Format: int64 */
            pull_request_review_id?: number;
            pull_request_url?: string;
            resolver?: components["schemas"]["User"];
            /** Format: date-time */
            updated_at?: string;
            user?: components["schemas"]["User"];
        };
        /** @description PullReviewRequestOptions are options to add or remove pull review requests */
        PullReviewRequestOptions: {
            reviewers?: string[];
            team_reviewers?: string[];
        };
        /** @description PushMirror represents information of a push mirror */
        PushMirror: {
            /** Format: date-time */
            created?: string;
            /** @description The sync interval for automatic updates */
            interval?: string;
            /** @description The last error message encountered during sync */
            last_error?: string;
            /** Format: date-time */
            last_update?: string;
            /** @description The remote repository URL being mirrored to */
            remote_address?: string;
            /** @description The name of the remote in the git configuration */
            remote_name?: string;
            /** @description The name of the source repository */
            repo_name?: string;
            /** @description Whether to sync on every commit */
            sync_on_commit?: boolean;
        };
        /** @description Reaction contain one reaction */
        Reaction: {
            /** @description The reaction content (e.g., emoji or reaction type) */
            content?: string;
            /** Format: date-time */
            created_at?: string;
            user?: components["schemas"]["User"];
        };
        /** Reference represents a Git reference. */
        Reference: {
            object?: components["schemas"]["GitObject"];
            /** @description The name of the Git reference (e.g., refs/heads/main) */
            ref?: string;
            /** @description The URL to access this Git reference */
            url?: string;
        };
        /** @description Release represents a repository release */
        Release: {
            /** @description The files attached to the release */
            assets?: components["schemas"]["Attachment"][];
            author?: components["schemas"]["User"];
            /** @description The release notes or description */
            body?: string;
            /** Format: date-time */
            created_at?: string;
            /** @description Whether the release is a draft */
            draft?: boolean;
            /** @description The HTML URL to view the release */
            html_url?: string;
            /**
             * Format: int64
             * @description The unique identifier of the release
             */
            id?: number;
            /** @description The display title of the release */
            name?: string;
            /** @description Whether the release is a prerelease */
            prerelease?: boolean;
            /** Format: date-time */
            published_at?: string;
            /** @description The name of the git tag associated with the release */
            tag_name?: string;
            /** @description The URL to download the tarball archive */
            tarball_url?: string;
            /** @description The target commitish for the release */
            target_commitish?: string;
            /** @description The URL template for uploading release assets */
            upload_url?: string;
            /** @description The API URL of the release */
            url?: string;
            /** @description The URL to download the zip archive */
            zipball_url?: string;
        };
        /** @description RenameBranchRepoOption options when renaming a branch in a repository */
        RenameBranchRepoOption: {
            /** @description New branch name */
            name: string;
        };
        /** @description RenameOrgOption options when renaming an organization */
        RenameOrgOption: {
            /** @description New username for this org. This name cannot be in use yet by any other user. */
            new_name: string;
        };
        /** @description RenameUserOption options when renaming a user */
        RenameUserOption: {
            /** @description New username for this user. This name cannot be in use yet by any other user. */
            new_username: string;
        };
        /** @description RepoCollaboratorPermission to get repository permission for a collaborator */
        RepoCollaboratorPermission: {
            /** @description Permission level of the collaborator */
            permission?: string;
            /** @description RoleName is the name of the permission role */
            role_name?: string;
            user?: components["schemas"]["User"];
        };
        /** RepoCommit contains information of a commit in the context of a repository. */
        RepoCommit: {
            author?: components["schemas"]["CommitUser"];
            committer?: components["schemas"]["CommitUser"];
            /** @description Message is the commit message */
            message?: string;
            tree?: components["schemas"]["CommitMeta"];
            /** @description URL is the API URL for the commit */
            url?: string;
            verification?: components["schemas"]["PayloadCommitVerification"];
        };
        /** @description RepoTopicOptions a collection of repo topic names */
        RepoTopicOptions: {
            /** @description list of topic names */
            topics?: string[];
        };
        /** @description RepoTransfer represents a pending repo transfer */
        RepoTransfer: {
            doer?: components["schemas"]["User"];
            recipient?: components["schemas"]["User"];
            teams?: components["schemas"]["Team"][];
        };
        /** @description Repository represents a repository */
        Repository: {
            allow_fast_forward_only_merge?: boolean;
            allow_manual_merge?: boolean;
            allow_merge_commits?: boolean;
            allow_rebase?: boolean;
            allow_rebase_explicit?: boolean;
            allow_rebase_update?: boolean;
            allow_squash_merge?: boolean;
            archived?: boolean;
            /** Format: date-time */
            archived_at?: string;
            autodetect_manual_merge?: boolean;
            avatar_url?: string;
            clone_url?: string;
            /** Format: date-time */
            created_at?: string;
            default_allow_maintainer_edit?: boolean;
            default_branch?: string;
            default_delete_branch_after_merge?: boolean;
            default_merge_style?: string;
            description?: string;
            empty?: boolean;
            external_tracker?: components["schemas"]["ExternalTracker"];
            external_wiki?: components["schemas"]["ExternalWiki"];
            fork?: boolean;
            /** Format: int64 */
            forks_count?: number;
            full_name?: string;
            has_actions?: boolean;
            has_code?: boolean;
            has_issues?: boolean;
            has_packages?: boolean;
            has_projects?: boolean;
            has_pull_requests?: boolean;
            has_releases?: boolean;
            has_wiki?: boolean;
            html_url?: string;
            /** Format: int64 */
            id?: number;
            ignore_whitespace_conflicts?: boolean;
            internal?: boolean;
            internal_tracker?: components["schemas"]["InternalTracker"];
            language?: string;
            languages_url?: string;
            licenses?: string[];
            link?: string;
            mirror?: boolean;
            mirror_interval?: string;
            /** Format: date-time */
            mirror_updated?: string;
            name?: string;
            /**
             * @description ObjectFormatName of the underlying git repository
             * @enum {string}
             */
            object_format_name?: "sha1" | "sha256";
            /** Format: int64 */
            open_issues_count?: number;
            /** Format: int64 */
            open_pr_counter?: number;
            original_url?: string;
            owner?: components["schemas"]["User"];
            parent?: components["schemas"]["Repository"];
            permissions?: components["schemas"]["Permission"];
            private?: boolean;
            projects_mode?: string;
            /** Format: int64 */
            release_counter?: number;
            repo_transfer?: components["schemas"]["RepoTransfer"];
            /** Format: int64 */
            size?: number;
            ssh_url?: string;
            /** Format: int64 */
            stars_count?: number;
            template?: boolean;
            topics?: string[];
            /** Format: date-time */
            updated_at?: string;
            url?: string;
            /** Format: int64 */
            watchers_count?: number;
            website?: string;
        };
        /** @description RepositoryMeta basic repository information */
        RepositoryMeta: {
            full_name?: string;
            /** Format: int64 */
            id?: number;
            name?: string;
            owner?: string;
        };
        /** @description ReviewStateType review state type */
        ReviewStateType: string;
        /** @description SearchResults results of a successful search */
        SearchResults: {
            /** @description Data contains the repository search results */
            data?: components["schemas"]["Repository"][];
            /** @description OK indicates if the search was successful */
            ok?: boolean;
        };
        /** @description Secret represents a secret */
        Secret: {
            /** Format: date-time */
            created_at?: string;
            /** @description the secret's description */
            description?: string;
            /** @description the secret's name */
            name?: string;
        };
        /** @description ServerVersion wraps the version of the server */
        ServerVersion: {
            /** @description Version is the server version string */
            version?: string;
        };
        /** @description StateType issue state type */
        StateType: string;
        /** @description StopWatch represent a running stopwatch */
        StopWatch: {
            /** Format: date-time */
            created?: string;
            /** @description Duration is a human-readable duration string */
            duration?: string;
            /**
             * Format: int64
             * @description IssueIndex is the index number of the associated issue
             */
            issue_index?: number;
            /** @description IssueTitle is the title of the associated issue */
            issue_title?: string;
            /** @description RepoName is the name of the repository */
            repo_name?: string;
            /** @description RepoOwnerName is the name of the repository owner */
            repo_owner_name?: string;
            /**
             * Format: int64
             * @description Seconds is the total elapsed time in seconds
             */
            seconds?: number;
        };
        /** @description SubmitPullReviewOptions are options to submit a pending pull review */
        SubmitPullReviewOptions: {
            body?: string;
            event?: components["schemas"]["ReviewStateType"];
        };
        /** @description Tag represents a repository tag */
        Tag: {
            commit?: components["schemas"]["CommitMeta"];
            /** @description The ID (SHA) of the tag */
            id?: string;
            /** @description The message associated with the tag */
            message?: string;
            /** @description The name of the tag */
            name?: string;
            /** @description The URL to download the tarball archive */
            tarball_url?: string;
            /** @description The URL to download the zipball archive */
            zipball_url?: string;
        };
        /** @description TagProtection represents a tag protection */
        TagProtection: {
            /** Format: date-time */
            created_at?: string;
            /**
             * Format: int64
             * @description The unique identifier of the tag protection
             */
            id?: number;
            /** @description The pattern to match tag names for protection */
            name_pattern?: string;
            /** Format: date-time */
            updated_at?: string;
            /** @description List of team names allowed to create/delete protected tags */
            whitelist_teams?: string[];
            /** @description List of usernames allowed to create/delete protected tags */
            whitelist_usernames?: string[];
        };
        /** @description Team represents a team in an organization */
        Team: {
            /** @description Whether the team can create repositories in the organization */
            can_create_org_repo?: boolean;
            /** @description The description of the team */
            description?: string;
            /**
             * Format: int64
             * @description The unique identifier of the team
             */
            id?: number;
            /** @description Whether the team has access to all repositories in the organization */
            includes_all_repositories?: boolean;
            /** @description The name of the team */
            name?: string;
            organization?: components["schemas"]["Organization"];
            /** @enum {string} */
            permission?: "none" | "read" | "write" | "admin" | "owner";
            /**
             * @example [
             *       "repo.code",
             *       "repo.issues",
             *       "repo.ext_issues",
             *       "repo.wiki",
             *       "repo.pulls",
             *       "repo.releases",
             *       "repo.projects",
             *       "repo.ext_wiki"
             *     ]
             */
            units?: string[];
            /**
             * @example {
             *       "repo.code": "read",
             *       "repo.ext_issues": "none",
             *       "repo.ext_wiki": "none",
             *       "repo.issues": "write",
             *       "repo.projects": "none",
             *       "repo.pulls": "owner",
             *       "repo.releases": "none",
             *       "repo.wiki": "admin"
             *     }
             */
            units_map?: {
                [key: string]: string;
            };
        };
        /**
         * Format: int64
         * @description TimeStamp defines a timestamp
         */
        TimeStamp: number;
        /** @description TimelineComment represents a timeline comment (comment of any type) on a commit or issue */
        TimelineComment: {
            assignee?: components["schemas"]["User"];
            assignee_team?: components["schemas"]["Team"];
            /** @description Body contains the timeline event content */
            body?: string;
            /** Format: date-time */
            created_at?: string;
            dependent_issue?: components["schemas"]["Issue"];
            /** @description HTMLURL is the web URL for viewing the comment */
            html_url?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the timeline comment
             */
            id?: number;
            /** @description IssueURL is the API URL for the issue */
            issue_url?: string;
            label?: components["schemas"]["Label"];
            milestone?: components["schemas"]["Milestone"];
            new_ref?: string;
            new_title?: string;
            old_milestone?: components["schemas"]["Milestone"];
            /** Format: int64 */
            old_project_id?: number;
            old_ref?: string;
            old_title?: string;
            /** Format: int64 */
            project_id?: number;
            /** @description PRURL is the API URL for the pull request (if applicable) */
            pull_request_url?: string;
            ref_action?: string;
            ref_comment?: components["schemas"]["Comment"];
            /** @description commit SHA where issue/PR was referenced */
            ref_commit_sha?: string;
            ref_issue?: components["schemas"]["Issue"];
            /** @description whether the assignees were removed or added */
            removed_assignee?: boolean;
            resolve_doer?: components["schemas"]["User"];
            /** Format: int64 */
            review_id?: number;
            tracked_time?: components["schemas"]["TrackedTime"];
            /** @description Type indicates the type of timeline event */
            type?: string;
            /** Format: date-time */
            updated_at?: string;
            user?: components["schemas"]["User"];
        };
        /** @description TopicName a list of repo topic names */
        TopicName: {
            /** @description List of topic names */
            topics?: string[];
        };
        /** @description TopicResponse for returning topics */
        TopicResponse: {
            /**
             * Format: date-time
             * @description The date and time when the topic was created
             */
            created?: string;
            /**
             * Format: int64
             * @description The unique identifier of the topic
             */
            id?: number;
            /**
             * Format: int64
             * @description The number of repositories using this topic
             */
            repo_count?: number;
            /** @description The name of the topic */
            topic_name?: string;
            /**
             * Format: date-time
             * @description The date and time when the topic was last updated
             */
            updated?: string;
        };
        /** @description TrackedTime worked time for an issue / pr */
        TrackedTime: {
            /** Format: date-time */
            created?: string;
            /**
             * Format: int64
             * @description ID is the unique identifier for the tracked time entry
             */
            id?: number;
            issue?: components["schemas"]["Issue"];
            /**
             * Format: int64
             * @description deprecated (only for backwards compatibility)
             */
            issue_id?: number;
            /**
             * Format: int64
             * @description Time in seconds
             */
            time?: number;
            /**
             * Format: int64
             * @description deprecated (only for backwards compatibility)
             */
            user_id?: number;
            /** @description username of the user */
            user_name?: string;
        };
        /** @description TransferRepoOption options when transfer a repository's ownership */
        TransferRepoOption: {
            new_owner: string;
            /** @description ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories. */
            team_ids?: number[];
        };
        /** @description UpdateBranchProtectionPriories a list to update the branch protection rule priorities */
        UpdateBranchProtectionPriories: {
            ids?: number[];
        };
        /**
         * @description UpdateFileOptions options for updating files
         *     Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
         */
        UpdateFileOptions: {
            author?: components["schemas"]["Identity"];
            /** @description branch (optional) to base this file from. if not given, the default branch is used */
            branch?: string;
            committer?: components["schemas"]["Identity"];
            /** @description content must be base64 encoded */
            content: string;
            dates?: components["schemas"]["CommitDateOptions"];
            /** @description from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL */
            from_path?: string;
            /** @description message (optional) for the commit of this file. if not supplied, a default message will be used */
            message?: string;
            /** @description new_branch (optional) will make a new branch from `branch` before creating the file */
            new_branch?: string;
            /** @description the blob ID (SHA) for the file that already exists, it is required for changing existing files */
            sha: string;
            /** @description Add a Signed-off-by trailer by the committer at the end of the commit log message. */
            signoff?: boolean;
        };
        /** @description UpdateRepoAvatarUserOption options when updating the repo avatar */
        UpdateRepoAvatarOption: {
            /** @description image must be base64 encoded */
            image?: string;
        };
        /** @description UpdateUserAvatarUserOption options when updating the user avatar */
        UpdateUserAvatarOption: {
            /** @description image must be base64 encoded */
            image?: string;
        };
        /** @description UpdateVariableOption the option when updating variable */
        UpdateVariableOption: {
            /** @description Description of the variable to update */
            description?: string;
            /** @description New name for the variable. If the field is empty, the variable name won't be updated. */
            name?: string;
            /** @description Value of the variable to update */
            value: string;
        };
        /** @description User represents a user */
        User: {
            /** @description Is user active */
            active?: boolean;
            /** @description URL to the user's avatar */
            avatar_url?: string;
            /** Format: date-time */
            created?: string;
            /** @description the user's description */
            description?: string;
            /** Format: email */
            email?: string;
            /**
             * Format: int64
             * @description user counts
             */
            followers_count?: number;
            /** Format: int64 */
            following_count?: number;
            /** @description the user's full name */
            full_name?: string;
            /** @description URL to the user's gitea page */
            html_url?: string;
            /**
             * Format: int64
             * @description the user's id
             */
            id?: number;
            /** @description Is the user an administrator */
            is_admin?: boolean;
            /** @description User locale */
            language?: string;
            /** Format: date-time */
            last_login?: string;
            /** @description the user's location */
            location?: string;
            /** @description login of the user, same as `username` */
            login?: string;
            /**
             * @description identifier of the user, provided by the external authenticator (if configured)
             * @default empty
             */
            login_name: string;
            /** @description Is user login prohibited */
            prohibit_login?: boolean;
            /** @description Is user restricted */
            restricted?: boolean;
            /**
             * Format: int64
             * @description The ID of the user's Authentication Source
             */
            source_id?: number;
            /** Format: int64 */
            starred_repos_count?: number;
            /** @description User visibility level option: public, limited, private */
            visibility?: string;
            /** @description the user's website */
            website?: string;
        };
        /** @description UserBadgeOption options for link between users and badges */
        UserBadgeOption: {
            /**
             * @example [
             *       "badge1",
             *       "badge2"
             *     ]
             */
            badge_slugs?: string[];
        };
        /** @description UserHeatmapData represents the data needed to create a heatmap */
        UserHeatmapData: {
            /** Format: int64 */
            contributions?: number;
            timestamp?: components["schemas"]["TimeStamp"];
        };
        /** @description UserSettings represents user settings */
        UserSettings: {
            description?: string;
            diff_view_style?: string;
            full_name?: string;
            hide_activity?: boolean;
            /** @description Privacy */
            hide_email?: boolean;
            language?: string;
            location?: string;
            theme?: string;
            website?: string;
        };
        /** @description UserSettingsOptions represents options to change user settings */
        UserSettingsOptions: {
            description?: string;
            diff_view_style?: string;
            full_name?: string;
            hide_activity?: boolean;
            /** @description Privacy */
            hide_email?: boolean;
            language?: string;
            location?: string;
            theme?: string;
            website?: string;
        };
        /** @description WatchInfo represents an API watch status of one repository */
        WatchInfo: {
            /**
             * Format: date-time
             * @description The timestamp when the watch status was created
             */
            created_at?: string;
            /** @description Whether notifications for the repository are ignored */
            ignored?: boolean;
            /** @description The reason for the current watch status */
            reason?: unknown;
            /** @description The URL of the repository being watched */
            repository_url?: string;
            /** @description Whether the repository is being watched for notifications */
            subscribed?: boolean;
            /** @description The URL for managing the watch status */
            url?: string;
        };
        /** @description WikiCommit page commit/revision */
        WikiCommit: {
            author?: components["schemas"]["CommitUser"];
            commiter?: components["schemas"]["CommitUser"];
            /** @description The commit message */
            message?: string;
            /** @description The commit SHA hash */
            sha?: string;
        };
        /** @description WikiCommitList commit/revision list */
        WikiCommitList: {
            /** @description The list of wiki commits */
            commits?: components["schemas"]["WikiCommit"][];
            /**
             * Format: int64
             * @description The total count of commits
             */
            count?: number;
        };
        /** @description WikiPage a wiki page */
        WikiPage: {
            /**
             * Format: int64
             * @description The number of commits that modified this page
             */
            commit_count?: number;
            /** @description Page content, base64 encoded */
            content_base64?: string;
            /** @description The footer content for the wiki page */
            footer?: string;
            /** @description The HTML URL to view the wiki page */
            html_url?: string;
            last_commit?: components["schemas"]["WikiCommit"];
            /** @description The sidebar content for the wiki page */
            sidebar?: string;
            /** @description The sub URL path for the wiki page */
            sub_url?: string;
            /** @description The title of the wiki page */
            title?: string;
        };
        /** @description WikiPageMetaData wiki page meta information */
        WikiPageMetaData: {
            /** @description The HTML URL to view the wiki page */
            html_url?: string;
            last_commit?: components["schemas"]["WikiCommit"];
            /** @description The sub URL path for the wiki page */
            sub_url?: string;
            /** @description The title of the wiki page */
            title?: string;
        };
    };
    responses: {
        /** @description AccessToken represents an API access token. */
        AccessToken: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["AccessToken"];
                "text/html": components["schemas"]["AccessToken"];
            };
        };
        /** @description AccessTokenList represents a list of API access token. */
        AccessTokenList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["AccessToken"][];
                "text/html": components["schemas"]["AccessToken"][];
            };
        };
        /** @description ActionVariable */
        ActionVariable: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionVariable"];
                "text/html": components["schemas"]["ActionVariable"];
            };
        };
        /** @description ActionWorkflow */
        ActionWorkflow: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionWorkflow"];
                "text/html": components["schemas"]["ActionWorkflow"];
            };
        };
        /** @description ActionWorkflowList */
        ActionWorkflowList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionWorkflowResponse"];
                "text/html": components["schemas"]["ActionWorkflowResponse"];
            };
        };
        /** @description ActivityFeedsList */
        ActivityFeedsList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Activity"][];
                "text/html": components["schemas"]["Activity"][];
            };
        };
        /** @description ActivityPub */
        ActivityPub: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActivityPub"];
                "text/html": components["schemas"]["ActivityPub"];
            };
        };
        /** @description AnnotatedTag */
        AnnotatedTag: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["AnnotatedTag"];
                "text/html": components["schemas"]["AnnotatedTag"];
            };
        };
        /** @description Artifact */
        Artifact: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionArtifact"];
                "text/html": components["schemas"]["ActionArtifact"];
            };
        };
        /** @description ArtifactsList */
        ArtifactsList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionArtifactsResponse"];
                "text/html": components["schemas"]["ActionArtifactsResponse"];
            };
        };
        /** @description Attachment */
        Attachment: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Attachment"];
                "text/html": components["schemas"]["Attachment"];
            };
        };
        /** @description AttachmentList */
        AttachmentList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Attachment"][];
                "text/html": components["schemas"]["Attachment"][];
            };
        };
        /** @description BadgeList */
        BadgeList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Badge"][];
                "text/html": components["schemas"]["Badge"][];
            };
        };
        /** @description Branch */
        Branch: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Branch"];
                "text/html": components["schemas"]["Branch"];
            };
        };
        /** @description BranchList */
        BranchList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Branch"][];
                "text/html": components["schemas"]["Branch"][];
            };
        };
        /** @description BranchProtection */
        BranchProtection: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["BranchProtection"];
                "text/html": components["schemas"]["BranchProtection"];
            };
        };
        /** @description BranchProtectionList */
        BranchProtectionList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["BranchProtection"][];
                "text/html": components["schemas"]["BranchProtection"][];
            };
        };
        /** @description ChangedFileList */
        ChangedFileList: {
            headers: {
                /** @description True if there is another page */
                "X-HasMore"?: boolean;
                /** @description The current page */
                "X-Page"?: number;
                /** @description Total number of pages */
                "X-PageCount"?: number;
                /** @description Commits per page */
                "X-PerPage"?: number;
                /** @description Total commit count */
                "X-Total"?: number;
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ChangedFile"][];
                "text/html": components["schemas"]["ChangedFile"][];
            };
        };
        /** @description CombinedStatus */
        CombinedStatus: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CombinedStatus"];
                "text/html": components["schemas"]["CombinedStatus"];
            };
        };
        /** @description Comment */
        Comment: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Comment"];
                "text/html": components["schemas"]["Comment"];
            };
        };
        /** @description CommentList */
        CommentList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Comment"][];
                "text/html": components["schemas"]["Comment"][];
            };
        };
        /** @description Commit */
        Commit: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Commit"];
                "text/html": components["schemas"]["Commit"];
            };
        };
        /** @description CommitList */
        CommitList: {
            headers: {
                /** @description True if there is another page */
                "X-HasMore"?: boolean;
                /** @description The current page */
                "X-Page"?: number;
                /** @description Total number of pages */
                "X-PageCount"?: number;
                /** @description Commits per page */
                "X-PerPage"?: number;
                /** @description Total commit count */
                "X-Total"?: number;
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Commit"][];
                "text/html": components["schemas"]["Commit"][];
            };
        };
        /** @description CommitStatus */
        CommitStatus: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CommitStatus"];
                "text/html": components["schemas"]["CommitStatus"];
            };
        };
        /** @description CommitStatusList */
        CommitStatusList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CommitStatus"][];
                "text/html": components["schemas"]["CommitStatus"][];
            };
        };
        Compare: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Compare"];
                "text/html": components["schemas"]["Compare"];
            };
        };
        ContentsExtResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ContentsExtResponse"];
                "text/html": components["schemas"]["ContentsExtResponse"];
            };
        };
        /** @description ContentsListResponse */
        ContentsListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ContentsResponse"][];
                "text/html": components["schemas"]["ContentsResponse"][];
            };
        };
        /** @description ContentsResponse */
        ContentsResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ContentsResponse"];
                "text/html": components["schemas"]["ContentsResponse"];
            };
        };
        /** @description CronList */
        CronList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Cron"][];
                "text/html": components["schemas"]["Cron"][];
            };
        };
        /** @description DeployKey */
        DeployKey: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DeployKey"];
                "text/html": components["schemas"]["DeployKey"];
            };
        };
        /** @description DeployKeyList */
        DeployKeyList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DeployKey"][];
                "text/html": components["schemas"]["DeployKey"][];
            };
        };
        /** @description EmailList */
        EmailList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Email"][];
                "text/html": components["schemas"]["Email"][];
            };
        };
        /** @description EmptyRepository */
        EmptyRepository: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["APIError"];
                "text/html": components["schemas"]["APIError"];
            };
        };
        /** @description FileDeleteResponse */
        FileDeleteResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FileDeleteResponse"];
                "text/html": components["schemas"]["FileDeleteResponse"];
            };
        };
        /** @description FileResponse */
        FileResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FileResponse"];
                "text/html": components["schemas"]["FileResponse"];
            };
        };
        /** @description FilesResponse */
        FilesResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FilesResponse"];
                "text/html": components["schemas"]["FilesResponse"];
            };
        };
        /** @description GPGKey */
        GPGKey: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GPGKey"];
                "text/html": components["schemas"]["GPGKey"];
            };
        };
        /** @description GPGKeyList */
        GPGKeyList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GPGKey"][];
                "text/html": components["schemas"]["GPGKey"][];
            };
        };
        /** @description GeneralAPISettings */
        GeneralAPISettings: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GeneralAPISettings"];
                "text/html": components["schemas"]["GeneralAPISettings"];
            };
        };
        /** @description GeneralAttachmentSettings */
        GeneralAttachmentSettings: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GeneralAttachmentSettings"];
                "text/html": components["schemas"]["GeneralAttachmentSettings"];
            };
        };
        /** @description GeneralRepoSettings */
        GeneralRepoSettings: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GeneralRepoSettings"];
                "text/html": components["schemas"]["GeneralRepoSettings"];
            };
        };
        /** @description GeneralUISettings */
        GeneralUISettings: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GeneralUISettings"];
                "text/html": components["schemas"]["GeneralUISettings"];
            };
        };
        /** @description GitBlobResponse */
        GitBlobResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GitBlobResponse"];
                "text/html": components["schemas"]["GitBlobResponse"];
            };
        };
        /** @description GitHook */
        GitHook: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GitHook"];
                "text/html": components["schemas"]["GitHook"];
            };
        };
        /** @description GitHookList */
        GitHookList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GitHook"][];
                "text/html": components["schemas"]["GitHook"][];
            };
        };
        /** @description GitTreeResponse */
        GitTreeResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GitTreeResponse"];
                "text/html": components["schemas"]["GitTreeResponse"];
            };
        };
        /** @description GitignoreTemplateInfo */
        GitignoreTemplateInfo: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GitignoreTemplateInfo"];
                "text/html": components["schemas"]["GitignoreTemplateInfo"];
            };
        };
        /** @description GitignoreTemplateList */
        GitignoreTemplateList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string[];
                "text/html": string[];
            };
        };
        /** @description Hook */
        Hook: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Hook"];
                "text/html": components["schemas"]["Hook"];
            };
        };
        /** @description HookList */
        HookList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Hook"][];
                "text/html": components["schemas"]["Hook"][];
            };
        };
        /** @description Issue */
        Issue: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Issue"];
                "text/html": components["schemas"]["Issue"];
            };
        };
        /** @description IssueDeadline */
        IssueDeadline: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["IssueDeadline"];
                "text/html": components["schemas"]["IssueDeadline"];
            };
        };
        /** @description IssueList */
        IssueList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Issue"][];
                "text/html": components["schemas"]["Issue"][];
            };
        };
        /** @description IssueTemplates */
        IssueTemplates: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["IssueTemplate"][];
                "text/html": components["schemas"]["IssueTemplate"][];
            };
        };
        /** @description Label */
        Label: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Label"];
                "text/html": components["schemas"]["Label"];
            };
        };
        /** @description LabelList */
        LabelList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Label"][];
                "text/html": components["schemas"]["Label"][];
            };
        };
        /** @description LabelTemplateInfo */
        LabelTemplateInfo: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LabelTemplate"][];
                "text/html": components["schemas"]["LabelTemplate"][];
            };
        };
        /** @description LabelTemplateList */
        LabelTemplateList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string[];
                "text/html": string[];
            };
        };
        /** @description LanguageStatistics */
        LanguageStatistics: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    [key: string]: number;
                };
                "text/html": {
                    [key: string]: number;
                };
            };
        };
        /** @description LicenseTemplateInfo */
        LicenseTemplateInfo: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LicenseTemplateInfo"];
                "text/html": components["schemas"]["LicenseTemplateInfo"];
            };
        };
        /** @description LicenseTemplateList */
        LicenseTemplateList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LicensesTemplateListEntry"][];
                "text/html": components["schemas"]["LicensesTemplateListEntry"][];
            };
        };
        /** @description LicensesList */
        LicensesList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string[];
                "text/html": string[];
            };
        };
        /** @description MarkdownRender is a rendered markdown document */
        MarkdownRender: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string;
                "text/html": string;
            };
        };
        /** @description MarkupRender is a rendered markup document */
        MarkupRender: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string;
                "text/html": string;
            };
        };
        MergeUpstreamRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MergeUpstreamRequest"];
                "text/html": components["schemas"]["MergeUpstreamRequest"];
            };
        };
        MergeUpstreamResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MergeUpstreamResponse"];
                "text/html": components["schemas"]["MergeUpstreamResponse"];
            };
        };
        /** @description Milestone */
        Milestone: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Milestone"];
                "text/html": components["schemas"]["Milestone"];
            };
        };
        /** @description MilestoneList */
        MilestoneList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Milestone"][];
                "text/html": components["schemas"]["Milestone"][];
            };
        };
        /** @description NodeInfo */
        NodeInfo: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["NodeInfo"];
                "text/html": components["schemas"]["NodeInfo"];
            };
        };
        /** @description Note */
        Note: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Note"];
                "text/html": components["schemas"]["Note"];
            };
        };
        /** @description Number of unread notifications */
        NotificationCount: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["NotificationCount"];
                "text/html": components["schemas"]["NotificationCount"];
            };
        };
        /** @description NotificationThread */
        NotificationThread: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["NotificationThread"];
                "text/html": components["schemas"]["NotificationThread"];
            };
        };
        /** @description NotificationThreadList */
        NotificationThreadList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["NotificationThread"][];
                "text/html": components["schemas"]["NotificationThread"][];
            };
        };
        /** @description OAuth2Application */
        OAuth2Application: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["OAuth2Application"];
                "text/html": components["schemas"]["OAuth2Application"];
            };
        };
        /** @description OAuth2ApplicationList represents a list of OAuth2 applications. */
        OAuth2ApplicationList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["OAuth2Application"][];
                "text/html": components["schemas"]["OAuth2Application"][];
            };
        };
        /** @description Organization */
        Organization: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Organization"];
                "text/html": components["schemas"]["Organization"];
            };
        };
        /** @description OrganizationList */
        OrganizationList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Organization"][];
                "text/html": components["schemas"]["Organization"][];
            };
        };
        /** @description OrganizationPermissions */
        OrganizationPermissions: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["OrganizationPermissions"];
                "text/html": components["schemas"]["OrganizationPermissions"];
            };
        };
        /** @description Package */
        Package: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Package"];
                "text/html": components["schemas"]["Package"];
            };
        };
        /** @description PackageFileList */
        PackageFileList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PackageFile"][];
                "text/html": components["schemas"]["PackageFile"][];
            };
        };
        /** @description PackageList */
        PackageList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Package"][];
                "text/html": components["schemas"]["Package"][];
            };
        };
        /** @description PublicKey */
        PublicKey: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PublicKey"];
                "text/html": components["schemas"]["PublicKey"];
            };
        };
        /** @description PublicKeyList */
        PublicKeyList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PublicKey"][];
                "text/html": components["schemas"]["PublicKey"][];
            };
        };
        /** @description PullRequest */
        PullRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PullRequest"];
                "text/html": components["schemas"]["PullRequest"];
            };
        };
        /** @description PullRequestList */
        PullRequestList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PullRequest"][];
                "text/html": components["schemas"]["PullRequest"][];
            };
        };
        /** @description PullReview */
        PullReview: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PullReview"];
                "text/html": components["schemas"]["PullReview"];
            };
        };
        /** @description PullComment */
        PullReviewComment: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PullReviewComment"];
                "text/html": components["schemas"]["PullReviewComment"];
            };
        };
        /** @description PullCommentList */
        PullReviewCommentList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PullReviewComment"][];
                "text/html": components["schemas"]["PullReviewComment"][];
            };
        };
        /** @description PullReviewList */
        PullReviewList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PullReview"][];
                "text/html": components["schemas"]["PullReview"][];
            };
        };
        /** @description PushMirror */
        PushMirror: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PushMirror"];
                "text/html": components["schemas"]["PushMirror"];
            };
        };
        /** @description PushMirrorList */
        PushMirrorList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PushMirror"][];
                "text/html": components["schemas"]["PushMirror"][];
            };
        };
        /** @description Reaction */
        Reaction: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Reaction"];
                "text/html": components["schemas"]["Reaction"];
            };
        };
        /** @description ReactionList */
        ReactionList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Reaction"][];
                "text/html": components["schemas"]["Reaction"][];
            };
        };
        /** @description Reference */
        Reference: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Reference"];
                "text/html": components["schemas"]["Reference"];
            };
        };
        /** @description ReferenceList */
        ReferenceList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Reference"][];
                "text/html": components["schemas"]["Reference"][];
            };
        };
        /** @description RegistrationToken is response related to registration token */
        RegistrationToken: {
            headers: {
                token?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Release */
        Release: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Release"];
                "text/html": components["schemas"]["Release"];
            };
        };
        /** @description ReleaseList */
        ReleaseList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Release"][];
                "text/html": components["schemas"]["Release"][];
            };
        };
        /** @description RepoCollaboratorPermission */
        RepoCollaboratorPermission: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["RepoCollaboratorPermission"];
                "text/html": components["schemas"]["RepoCollaboratorPermission"];
            };
        };
        /** @description RepoIssueConfig */
        RepoIssueConfig: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["IssueConfig"];
                "text/html": components["schemas"]["IssueConfig"];
            };
        };
        /** @description RepoIssueConfigValidation */
        RepoIssueConfigValidation: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["IssueConfigValidation"];
                "text/html": components["schemas"]["IssueConfigValidation"];
            };
        };
        /** @description RepoNewIssuePinsAllowed */
        RepoNewIssuePinsAllowed: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["NewIssuePinsAllowed"];
                "text/html": components["schemas"]["NewIssuePinsAllowed"];
            };
        };
        /** @description Repository */
        Repository: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Repository"];
                "text/html": components["schemas"]["Repository"];
            };
        };
        /** @description RepositoryList */
        RepositoryList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Repository"][];
                "text/html": components["schemas"]["Repository"][];
            };
        };
        /** @description Runner */
        Runner: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionRunner"];
                "text/html": components["schemas"]["ActionRunner"];
            };
        };
        /** @description RunnerList */
        RunnerList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionRunnersResponse"];
                "text/html": components["schemas"]["ActionRunnersResponse"];
            };
        };
        /** @description SearchResults */
        SearchResults: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["SearchResults"];
                "text/html": components["schemas"]["SearchResults"];
            };
        };
        /** @description Secret */
        Secret: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Secret"];
                "text/html": components["schemas"]["Secret"];
            };
        };
        /** @description SecretList */
        SecretList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Secret"][];
                "text/html": components["schemas"]["Secret"][];
            };
        };
        /** @description ServerVersion */
        ServerVersion: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ServerVersion"];
                "text/html": components["schemas"]["ServerVersion"];
            };
        };
        /** @description StopWatch */
        StopWatch: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["StopWatch"];
                "text/html": components["schemas"]["StopWatch"];
            };
        };
        /** @description StopWatchList */
        StopWatchList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["StopWatch"][];
                "text/html": components["schemas"]["StopWatch"][];
            };
        };
        /** @description StringSlice */
        StringSlice: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string[];
                "text/html": string[];
            };
        };
        /** @description Tag */
        Tag: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Tag"];
                "text/html": components["schemas"]["Tag"];
            };
        };
        /** @description TagList */
        TagList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Tag"][];
                "text/html": components["schemas"]["Tag"][];
            };
        };
        /** @description TagProtection */
        TagProtection: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TagProtection"];
                "text/html": components["schemas"]["TagProtection"];
            };
        };
        /** @description TagProtectionList */
        TagProtectionList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TagProtection"][];
                "text/html": components["schemas"]["TagProtection"][];
            };
        };
        /** @description TasksList */
        TasksList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionTaskResponse"];
                "text/html": components["schemas"]["ActionTaskResponse"];
            };
        };
        /** @description Team */
        Team: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Team"];
                "text/html": components["schemas"]["Team"];
            };
        };
        /** @description TeamList */
        TeamList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Team"][];
                "text/html": components["schemas"]["Team"][];
            };
        };
        /** @description TimelineList */
        TimelineList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TimelineComment"][];
                "text/html": components["schemas"]["TimelineComment"][];
            };
        };
        /** @description TopicListResponse */
        TopicListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TopicResponse"][];
                "text/html": components["schemas"]["TopicResponse"][];
            };
        };
        /** @description TopicNames */
        TopicNames: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TopicName"];
                "text/html": components["schemas"]["TopicName"];
            };
        };
        /** @description TrackedTime */
        TrackedTime: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TrackedTime"];
                "text/html": components["schemas"]["TrackedTime"];
            };
        };
        /** @description TrackedTimeList */
        TrackedTimeList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TrackedTime"][];
                "text/html": components["schemas"]["TrackedTime"][];
            };
        };
        /** @description User */
        User: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["User"];
                "text/html": components["schemas"]["User"];
            };
        };
        /** @description UserHeatmapData */
        UserHeatmapData: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["UserHeatmapData"][];
                "text/html": components["schemas"]["UserHeatmapData"][];
            };
        };
        /** @description UserList */
        UserList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["User"][];
                "text/html": components["schemas"]["User"][];
            };
        };
        /** @description UserSettings */
        UserSettings: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["UserSettings"][];
                "text/html": components["schemas"]["UserSettings"][];
            };
        };
        /** @description VariableList */
        VariableList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionVariable"][];
                "text/html": components["schemas"]["ActionVariable"][];
            };
        };
        /** @description WatchInfo */
        WatchInfo: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WatchInfo"];
                "text/html": components["schemas"]["WatchInfo"];
            };
        };
        /** @description WikiCommitList */
        WikiCommitList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WikiCommitList"];
                "text/html": components["schemas"]["WikiCommitList"];
            };
        };
        /** @description WikiPage */
        WikiPage: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WikiPage"];
                "text/html": components["schemas"]["WikiPage"];
            };
        };
        /** @description WikiPageList */
        WikiPageList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WikiPageMetaData"][];
                "text/html": components["schemas"]["WikiPageMetaData"][];
            };
        };
        /** @description WorkflowJob */
        WorkflowJob: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionWorkflowJob"];
                "text/html": components["schemas"]["ActionWorkflowJob"];
            };
        };
        /** @description WorkflowJobsList */
        WorkflowJobsList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionWorkflowJobsResponse"];
                "text/html": components["schemas"]["ActionWorkflowJobsResponse"];
            };
        };
        /** @description WorkflowRun */
        WorkflowRun: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionWorkflowRun"];
                "text/html": components["schemas"]["ActionWorkflowRun"];
            };
        };
        /** @description WorkflowRunsList */
        WorkflowRunsList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ActionWorkflowRunsResponse"];
                "text/html": components["schemas"]["ActionWorkflowRunsResponse"];
            };
        };
        /** @description APIConflict is a conflict empty response */
        conflict: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APIEmpty is an empty response */
        empty: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APIError is error format response */
        error: {
            headers: {
                message?: string;
                url?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APIForbiddenError is a forbidden error response */
        forbidden: {
            headers: {
                message?: string;
                url?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APIInvalidTopicsError is error format response to invalid topics */
        invalidTopicsError: {
            headers: {
                invalidTopics?: string[];
                message?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APINotFound is a not found empty response */
        notFound: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description parameterBodies */
        parameterBodies: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LockIssueOption"];
                "text/html": components["schemas"]["LockIssueOption"];
            };
        };
        /** @description APIRedirect is a redirect response */
        redirect: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APIRepoArchivedError is an error that is raised when an archived repo should be modified */
        repoArchivedError: {
            headers: {
                message?: string;
                url?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description APIString is a string response */
        string: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string;
                "text/html": string;
            };
        };
        /** @description APIValidationError is error format response related to input validation */
        validationError: {
            headers: {
                message?: string;
                url?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
    };
    parameters: never;
    requestBodies: {
        CreateOAuth2ApplicationOptions: {
            content: {
                "application/json": components["schemas"]["CreateOAuth2ApplicationOptions"];
                "text/plain": components["schemas"]["CreateOAuth2ApplicationOptions"];
            };
        };
        CreateWikiPageOptions: {
            content: {
                "application/json": components["schemas"]["CreateWikiPageOptions"];
            };
        };
        EditLabelOption: {
            content: {
                "application/json": components["schemas"]["EditLabelOption"];
            };
        };
        CreateKeyOption: {
            content: {
                "application/json": components["schemas"]["CreateKeyOption"];
            };
        };
        CreateOrgOption: {
            content: {
                "application/json": components["schemas"]["CreateOrgOption"];
            };
        };
        IssueLabelsOption: {
            content: {
                "application/json": components["schemas"]["IssueLabelsOption"];
            };
        };
        UpdateUserAvatarOption: {
            content: {
                "application/json": components["schemas"]["UpdateUserAvatarOption"];
                "text/plain": components["schemas"]["UpdateUserAvatarOption"];
            };
        };
        CreateHookOption: {
            content: {
                "application/json": components["schemas"]["CreateHookOption"];
            };
        };
        EditReactionOption: {
            content: {
                "application/json": components["schemas"]["EditReactionOption"];
            };
        };
        EditHookOption: {
            content: {
                "application/json": components["schemas"]["EditHookOption"];
            };
        };
        CreateRepoOption: {
            content: {
                "application/json": components["schemas"]["CreateRepoOption"];
            };
        };
        CreateOrUpdateSecretOption: {
            content: {
                "application/json": components["schemas"]["CreateOrUpdateSecretOption"];
            };
        };
        UpdateVariableOption: {
            content: {
                "application/json": components["schemas"]["UpdateVariableOption"];
            };
        };
        CreateVariableOption: {
            content: {
                "application/json": components["schemas"]["CreateVariableOption"];
            };
        };
        CreateLabelOption: {
            content: {
                "application/json": components["schemas"]["CreateLabelOption"];
            };
        };
        EditIssueCommentOption: {
            content: {
                "application/json": components["schemas"]["EditIssueCommentOption"];
            };
        };
        issueCreateIssueCommentAttachment: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description attachment to upload
                     */
                    attachment: string;
                };
            };
        };
        EditAttachmentOptions: {
            content: {
                "application/json": components["schemas"]["EditAttachmentOptions"];
            };
        };
        IssueMeta: {
            content: {
                "application/json": components["schemas"]["IssueMeta"];
                "text/plain": components["schemas"]["IssueMeta"];
            };
        };
        PullReviewRequestOptions: {
            content: {
                "application/json": components["schemas"]["PullReviewRequestOptions"];
                "text/plain": components["schemas"]["PullReviewRequestOptions"];
            };
        };
    };
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    activitypubPerson: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description user ID of the user */
                "user-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActivityPub"];
        };
    };
    activitypubPersonInbox: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description user ID of the user */
                "user-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
        };
    };
    listAdminWorkflowJobs: {
        parameters: {
            query?: {
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowJobsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getAdminRunners: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunnersResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    adminCreateRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    getAdminRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunner"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteAdminRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description runner has been deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    listAdminWorkflowRuns: {
        parameters: {
            query?: {
                /** @description workflow event name */
                event?: string;
                /** @description workflow branch */
                branch?: string;
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description triggered by user */
                actor?: string;
                /** @description triggering sha of the workflow run */
                head_sha?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowRunsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    adminCronList: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CronList"];
            403: components["responses"]["forbidden"];
        };
    };
    adminCronRun: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description task to run */
                task: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    adminGetAllEmails: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["EmailList"];
            403: components["responses"]["forbidden"];
        };
    };
    adminSearchEmails: {
        parameters: {
            query?: {
                /** @description keyword */
                q?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["EmailList"];
            403: components["responses"]["forbidden"];
        };
    };
    adminListHooks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
                /** @description system, default or both kinds of webhooks */
                type?: "system" | "default" | "all";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["HookList"];
        };
    };
    adminCreateHook: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateHookOption"];
        responses: {
            201: components["responses"]["Hook"];
        };
    };
    adminGetHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the hook to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Hook"];
        };
    };
    adminDeleteHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the hook to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
        };
    };
    adminEditHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the hook to update */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditHookOption"];
        responses: {
            200: components["responses"]["Hook"];
        };
    };
    adminGetAllOrgs: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrganizationList"];
            403: components["responses"]["forbidden"];
        };
    };
    adminGetRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    adminUnadoptedList: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
                /** @description pattern of repositories to search for */
                pattern?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["StringSlice"];
            403: components["responses"]["forbidden"];
        };
    };
    adminAdoptRepository: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    adminDeleteUnadoptedRepository: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
        };
    };
    adminSearchUsers: {
        parameters: {
            query?: {
                /** @description ID of the user's login source to search for */
                source_id?: number;
                /** @description identifier of the user, provided by the external authenticator */
                login_name?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            403: components["responses"]["forbidden"];
        };
    };
    adminCreateUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateUserOption"];
            };
        };
        responses: {
            201: components["responses"]["User"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    adminDeleteUser: {
        parameters: {
            query?: {
                /** @description purge the user from the system completely */
                purge?: boolean;
            };
            header?: never;
            path: {
                /** @description username of the user to delete */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    adminEditUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose data is to be edited */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditUserOption"];
            };
        };
        responses: {
            200: components["responses"]["User"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    adminListUserBadges: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose badges are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["BadgeList"];
            404: components["responses"]["notFound"];
        };
    };
    adminAddUserBadges: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user to whom a badge is to be added */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserBadgeOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
        };
    };
    adminDeleteUserBadges: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose badge is to be deleted */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserBadgeOption"];
                "text/plain": components["schemas"]["UserBadgeOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    adminCreatePublicKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user who is to receive a public key */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateKeyOption"];
        responses: {
            201: components["responses"]["PublicKey"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    adminDeleteUserPublicKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose public key is to be deleted */
                username: string;
                /** @description id of the key to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    adminCreateOrg: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user who will own the created organization */
                username: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateOrgOption"];
        responses: {
            201: components["responses"]["Organization"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    adminRenameUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description current username of the user */
                username: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RenameUserOption"];
                "text/plain": components["schemas"]["RenameUserOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    adminCreateRepo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user who will own the created repository */
                username: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateRepoOption"];
            };
        };
        responses: {
            201: components["responses"]["Repository"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    listGitignoresTemplates: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GitignoreTemplateList"];
        };
    };
    getGitignoreTemplateInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the template */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GitignoreTemplateInfo"];
            404: components["responses"]["notFound"];
        };
    };
    listLabelTemplates: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LabelTemplateList"];
        };
    };
    getLabelTemplateInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the template */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LabelTemplateInfo"];
            404: components["responses"]["notFound"];
        };
    };
    listLicenseTemplates: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LicenseTemplateList"];
        };
    };
    getLicenseTemplateInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the license */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LicenseTemplateInfo"];
            404: components["responses"]["notFound"];
        };
    };
    renderMarkdown: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MarkdownOption"];
            };
        };
        responses: {
            200: components["responses"]["MarkdownRender"];
            422: components["responses"]["validationError"];
        };
    };
    renderMarkdownRaw: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Request body to render */
        requestBody: {
            content: {
                "text/plain": string;
            };
        };
        responses: {
            200: components["responses"]["MarkdownRender"];
            422: components["responses"]["validationError"];
        };
    };
    renderMarkup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MarkupOption"];
            };
        };
        responses: {
            200: components["responses"]["MarkupRender"];
            422: components["responses"]["validationError"];
        };
    };
    getNodeInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NodeInfo"];
        };
    };
    notifyGetList: {
        parameters: {
            query?: {
                /** @description If true, show notifications marked as read. Default value is false */
                all?: boolean;
                /** @description Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned. */
                "status-types"?: string[];
                /** @description filter notifications by subject type */
                "subject-type"?: ("issue" | "pull" | "commit" | "repository")[];
                /** @description Only show notifications updated after the given time. This is a timestamp in RFC 3339 format */
                since?: string;
                /** @description Only show notifications updated before the given time. This is a timestamp in RFC 3339 format */
                before?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationThreadList"];
        };
    };
    notifyReadList: {
        parameters: {
            query?: {
                /** @description Describes the last point that notifications were checked. Anything updated since this time will not be updated. */
                last_read_at?: string;
                /** @description If true, mark all notifications on this repo. Default value is false */
                all?: string;
                /** @description Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread. */
                "status-types"?: string[];
                /** @description Status to mark notifications as, Defaults to read. */
                "to-status"?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            205: components["responses"]["NotificationThreadList"];
        };
    };
    notifyNewAvailable: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationCount"];
        };
    };
    notifyGetThread: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of notification thread */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationThread"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    notifyReadThread: {
        parameters: {
            query?: {
                /** @description Status to mark notifications as */
                "to-status"?: string;
            };
            header?: never;
            path: {
                /** @description id of notification thread */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            205: components["responses"]["NotificationThread"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    createOrgRepoDeprecated: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateRepoOption"];
        responses: {
            201: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    orgGetAll: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrganizationList"];
        };
    };
    orgCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateOrgOption"];
        responses: {
            201: components["responses"]["Organization"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    orgGet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization to get */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Organization"];
            404: components["responses"]["notFound"];
        };
    };
    orgDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description organization that is to be deleted */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    orgEdit: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization to edit */
                org: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EditOrgOption"];
            };
        };
        responses: {
            200: components["responses"]["Organization"];
            404: components["responses"]["notFound"];
        };
    };
    getOrgWorkflowJobs: {
        parameters: {
            query?: {
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowJobsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getOrgRunners: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunnersResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    orgGetRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    orgCreateRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    getOrgRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunner"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteOrgRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description runner has been deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getOrgWorkflowRuns: {
        parameters: {
            query?: {
                /** @description workflow event name */
                event?: string;
                /** @description workflow branch */
                branch?: string;
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description triggered by user */
                actor?: string;
                /** @description triggering sha of the workflow run */
                head_sha?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowRunsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    orgListActionsSecrets: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["SecretList"];
            404: components["responses"]["notFound"];
        };
    };
    updateOrgSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of organization */
                org: string;
                /** @description name of the secret */
                secretname: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateOrUpdateSecretOption"];
        responses: {
            /** @description response when creating a secret */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when updating a secret */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteOrgSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of organization */
                org: string;
                /** @description name of the secret */
                secretname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description delete one secret of the organization */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getOrgVariablesList: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["VariableList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getOrgVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionVariable"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    updateOrgVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["UpdateVariableOption"];
        responses: {
            /** @description response when updating an org-level variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when updating an org-level variable */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    createOrgVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateVariableOption"];
        responses: {
            /** @description successfully created the org-level variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            /** @description variable name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["error"];
        };
    };
    deleteOrgVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionVariable"];
            /** @description response when deleting a variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when deleting a variable */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    orgListActivityFeeds: {
        parameters: {
            query?: {
                /** @description the date of the activities to be found */
                date?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the org */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActivityFeedsList"];
            404: components["responses"]["notFound"];
        };
    };
    orgUpdateAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["UpdateUserAvatarOption"];
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    orgDeleteAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    organizationListBlocks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
        };
    };
    organizationCheckUserBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user to check */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    organizationBlockUser: {
        parameters: {
            query?: {
                /** @description optional note for the block */
                note?: string;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user to block */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    organizationUnblockUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user to unblock */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    orgListHooks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["HookList"];
            404: components["responses"]["notFound"];
        };
    };
    orgCreateHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateHookOption"];
        responses: {
            201: components["responses"]["Hook"];
            404: components["responses"]["notFound"];
        };
    };
    orgGetHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the hook to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Hook"];
            404: components["responses"]["notFound"];
        };
    };
    orgDeleteHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the hook to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    orgEditHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the hook to update */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditHookOption"];
        responses: {
            200: components["responses"]["Hook"];
            404: components["responses"]["notFound"];
        };
    };
    orgListLabels: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LabelList"];
            404: components["responses"]["notFound"];
        };
    };
    orgCreateLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateLabelOption"];
        responses: {
            201: components["responses"]["Label"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    orgGetLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the label to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Label"];
            404: components["responses"]["notFound"];
        };
    };
    orgDeleteLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the label to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    orgEditLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description id of the label to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditLabelOption"];
        responses: {
            200: components["responses"]["Label"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    orgListMembers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    orgIsMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user to check for an organization membership */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description user is a member */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description redirection to /orgs/{org}/public_members/{username} */
            303: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user is not a member */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    orgDeleteMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user to remove from the organization */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description member removed */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
        };
    };
    orgListPublicMembers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    orgIsPublicMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user to check for a public organization membership */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description user is a public member */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description user is not a public member */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    orgPublicizeMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user whose membership is to be publicized */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description membership publicized */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    orgConcealMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
                /** @description username of the user whose membership is to be concealed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    renameOrg: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description existing org name */
                org: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RenameOrgOption"];
                "text/plain": components["schemas"]["RenameOrgOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            422: components["responses"]["validationError"];
        };
    };
    orgListRepos: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            404: components["responses"]["notFound"];
        };
    };
    createOrgRepo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateRepoOption"];
        responses: {
            201: components["responses"]["Repository"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    orgListTeams: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TeamList"];
            404: components["responses"]["notFound"];
        };
    };
    orgCreateTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateTeamOption"];
            };
        };
        responses: {
            201: components["responses"]["Team"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    teamSearch: {
        parameters: {
            query?: {
                /** @description keywords to search */
                q?: string;
                /** @description include search within team description (defaults to true) */
                include_desc?: boolean;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SearchResults of a successful search */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Team"][];
                        ok?: boolean;
                    };
                };
            };
            404: components["responses"]["notFound"];
        };
    };
    listPackages: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
                /** @description package type filter */
                type?: "alpine" | "cargo" | "chef" | "composer" | "conan" | "conda" | "container" | "cran" | "debian" | "generic" | "go" | "helm" | "maven" | "npm" | "nuget" | "pub" | "pypi" | "rpm" | "rubygems" | "swift" | "vagrant";
                /** @description name filter */
                q?: string;
            };
            header?: never;
            path: {
                /** @description owner of the packages */
                owner: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PackageList"];
            404: components["responses"]["notFound"];
        };
    };
    listPackageVersions: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PackageList"];
            404: components["responses"]["notFound"];
        };
    };
    getLatestPackageVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Package"];
            404: components["responses"]["notFound"];
        };
    };
    linkPackage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
                /** @description name of the repository to link. */
                repo_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    unlinkPackage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    getPackage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
                /** @description version of the package */
                version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Package"];
            404: components["responses"]["notFound"];
        };
    };
    deletePackage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
                /** @description version of the package */
                version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    listPackageFiles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the package */
                owner: string;
                /** @description type of the package */
                type: string;
                /** @description name of the package */
                name: string;
                /** @description version of the package */
                version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PackageFileList"];
            404: components["responses"]["notFound"];
        };
    };
    issueSearchIssues: {
        parameters: {
            query?: {
                /** @description State of the issue */
                state?: "open" | "closed" | "all";
                /** @description Comma-separated list of label names. Fetch only issues that have any of these labels. Non existent labels are discarded. */
                labels?: string;
                /** @description Comma-separated list of milestone names. Fetch only issues that have any of these milestones. Non existent milestones are discarded. */
                milestones?: string;
                /** @description Search string */
                q?: string;
                /** @description Repository ID to prioritize in the results */
                priority_repo_id?: number;
                /** @description Filter by issue type */
                type?: "issues" | "pulls";
                /** @description Only show issues updated after the given time (RFC 3339 format) */
                since?: string;
                /** @description Only show issues updated before the given time (RFC 3339 format) */
                before?: string;
                /** @description Filter issues or pulls assigned to the authenticated user */
                assigned?: boolean;
                /** @description Filter issues or pulls created by the authenticated user */
                created?: boolean;
                /** @description Filter issues or pulls mentioning the authenticated user */
                mentioned?: boolean;
                /** @description Filter pull requests where the authenticated user's review was requested */
                review_requested?: boolean;
                /** @description Filter pull requests reviewed by the authenticated user */
                reviewed?: boolean;
                /** @description Filter by repository owner */
                owner?: string;
                /** @description Filter by team (requires organization owner parameter) */
                team?: string;
                /** @description Page number of results to return (1-based) */
                page?: number;
                /** @description Number of items per page */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IssueList"];
            400: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    repoMigrate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MigrateRepoOptions"];
            };
        };
        responses: {
            201: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            /** @description The repository with the same name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            422: components["responses"]["validationError"];
        };
    };
    repoSearch: {
        parameters: {
            query?: {
                /** @description keyword */
                q?: string;
                /** @description Limit search to repositories with keyword as topic */
                topic?: boolean;
                /** @description include search of keyword within repository description */
                includeDesc?: boolean;
                /** @description search only for repos that the user with the given id owns or contributes to */
                uid?: number;
                /** @description repo owner to prioritize in the results */
                priority_owner_id?: number;
                /** @description search only for repos that belong to the given team id */
                team_id?: number;
                /** @description search only for repos that the user with the given id has starred */
                starredBy?: number;
                /** @description include private repositories this user has access to (defaults to true) */
                private?: boolean;
                /** @description show only pubic, private or all repositories (defaults to all) */
                is_private?: boolean;
                /** @description include template repositories this user has access to (defaults to true) */
                template?: boolean;
                /** @description show only archived, non-archived or all repositories (defaults to all) */
                archived?: boolean;
                /** @description type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative" */
                mode?: string;
                /** @description if `uid` is given, search only for repos that the user owns */
                exclusive?: boolean;
                /** @description sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha" */
                sort?: string;
                /** @description sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified. */
                order?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["SearchResults"];
            422: components["responses"]["validationError"];
        };
    };
    repoGet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Repository"];
            404: components["responses"]["notFound"];
        };
    };
    repoDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to delete */
                owner: string;
                /** @description name of the repo to delete */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoEdit: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to edit */
                owner: string;
                /** @description name of the repo to edit */
                repo: string;
            };
            cookie?: never;
        };
        /** @description Properties of a repo that you can edit */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditRepoOption"];
                "text/plain": components["schemas"]["EditRepoOption"];
            };
        };
        responses: {
            200: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    getArtifacts: {
        parameters: {
            query?: {
                /** @description name of the artifact */
                name?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ArtifactsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getArtifact: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description id of the artifact */
                artifact_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Artifact"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteArtifact: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description id of the artifact */
                artifact_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    downloadArtifact: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description id of the artifact */
                artifact_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description redirect to the blob download */
            302: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    listWorkflowJobs: {
        parameters: {
            query?: {
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowJobsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getWorkflowJob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description id of the job */
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowJob"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    downloadActionsRunJobLogs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description id of the job */
                job_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description output blob content */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getRepoRunners: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunnersResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    repoCreateRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    getRepoRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunner"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteRepoRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description runner has been deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getWorkflowRuns: {
        parameters: {
            query?: {
                /** @description workflow event name */
                event?: string;
                /** @description workflow branch */
                branch?: string;
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description triggered by user */
                actor?: string;
                /** @description triggering sha of the workflow run */
                head_sha?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowRunsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    GetWorkflowRun: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description id of the run */
                run: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowRun"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteActionRun: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description runid of the workflow run */
                run: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getArtifactsOfRun: {
        parameters: {
            query?: {
                /** @description name of the artifact */
                name?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description runid of the workflow run */
                run: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ArtifactsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    listWorkflowRunJobs: {
        parameters: {
            query?: {
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description runid of the workflow run */
                run: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowJobsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoListActionsSecrets: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["SecretList"];
            404: components["responses"]["notFound"];
        };
    };
    updateRepoSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repository */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description name of the secret */
                secretname: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateOrUpdateSecretOption"];
        responses: {
            /** @description response when creating a secret */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when updating a secret */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteRepoSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repository */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description name of the secret */
                secretname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description delete one secret of the repository */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    ListActionTasks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results, default maximum page size is 50 */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TasksList"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            422: components["responses"]["validationError"];
        };
    };
    getRepoVariablesList: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["VariableList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getRepoVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionVariable"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    updateRepoVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateVariableOption"];
                "text/plain": components["schemas"]["UpdateVariableOption"];
            };
        };
        responses: {
            /** @description response when updating a repo-level variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when updating a repo-level variable */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    createRepoVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateVariableOption"];
                "text/plain": components["schemas"]["CreateVariableOption"];
            };
        };
        responses: {
            /** @description response when creating a repo-level variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            /** @description variable name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            500: components["responses"]["error"];
        };
    };
    deleteRepoVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repository */
                repo: string;
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionVariable"];
            /** @description response when deleting a variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when deleting a variable */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    ActionsListRepositoryWorkflows: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionWorkflowList"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            500: components["responses"]["error"];
        };
    };
    ActionsGetWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the workflow */
                workflow_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionWorkflow"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            500: components["responses"]["error"];
        };
    };
    ActionsDisableWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the workflow */
                workflow_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    ActionsDispatchWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the workflow */
                workflow_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateActionWorkflowDispatch"];
                "text/plain": components["schemas"]["CreateActionWorkflowDispatch"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    ActionsEnableWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the workflow */
                workflow_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["conflict"];
            422: components["responses"]["validationError"];
        };
    };
    repoListActivityFeeds: {
        parameters: {
            query?: {
                /** @description the date of the activities to be found */
                date?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActivityFeedsList"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetArchive: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description the git reference for download with attached archive format (e.g. master.zip) */
                archive: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
        };
    };
    repoGetAssignees: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    repoUpdateAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateRepoAvatarOption"];
                "text/plain": components["schemas"]["UpdateRepoAvatarOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoListBranchProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["BranchProtectionList"];
        };
    };
    repoCreateBranchProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateBranchProtectionOption"];
            };
        };
        responses: {
            201: components["responses"]["BranchProtection"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoUpdateBranchProtectionPriories: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateBranchProtectionPriories"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetBranchProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of protected branch */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["BranchProtection"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteBranchProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of protected branch */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoEditBranchProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of protected branch */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditBranchProtectionOption"];
            };
        };
        responses: {
            200: components["responses"]["BranchProtection"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoListBranches: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["BranchList"];
        };
    };
    repoCreateBranch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateBranchRepoOption"];
            };
        };
        responses: {
            201: components["responses"]["Branch"];
            /** @description The branch is archived or a mirror. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The old branch does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The branch with the same name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetBranch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description branch to get */
                branch: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Branch"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteBranch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description branch to delete */
                branch: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["error"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoRenameBranch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the branch */
                branch: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RenameBranchRepoOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoListCollaborators: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCheckCollaborator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description username of the user to check for being a collaborator */
                collaborator: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoAddCollaborator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description username of the user to add or update as a collaborator */
                collaborator: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AddCollaboratorOption"];
                "text/plain": components["schemas"]["AddCollaboratorOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoDeleteCollaborator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description username of the collaborator to delete */
                collaborator: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetRepoPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description username of the collaborator whose permissions are to be obtained */
                collaborator: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepoCollaboratorPermission"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetAllCommits: {
        parameters: {
            query?: {
                /** @description SHA or branch to start listing commits from (usually 'master') */
                sha?: string;
                /** @description filepath of a file/dir */
                path?: string;
                /** @description Only commits after this date will be returned (ISO 8601 format) */
                since?: string;
                /** @description Only commits before this date will be returned (ISO 8601 format) */
                until?: string;
                /** @description include diff stats for every commit (disable for speedup, default 'true') */
                stat?: boolean;
                /** @description include verification for every commit (disable for speedup, default 'true') */
                verification?: boolean;
                /** @description include a list of affected files for every commit (disable for speedup, default 'true') */
                files?: boolean;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results (ignored if used with 'path') */
                limit?: number;
                /** @description commits that match the given specifier will not be listed. */
                not?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CommitList"];
            404: components["responses"]["notFound"];
            409: components["responses"]["EmptyRepository"];
        };
    };
    repoGetCombinedStatusByRef: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of branch/tag/commit */
                ref: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CombinedStatus"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoListStatusesByRef: {
        parameters: {
            query?: {
                /** @description type of sort */
                sort?: "oldest" | "recentupdate" | "leastupdate" | "leastindex" | "highestindex";
                /** @description type of state */
                state?: "pending" | "success" | "error" | "failure" | "warning";
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of branch/tag/commit */
                ref: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CommitStatusList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetCommitPullRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description SHA of the commit to get */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullRequest"];
            404: components["responses"]["notFound"];
        };
    };
    repoCompareDiff: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description compare two branches or commits */
                basehead: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Compare"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetContentsList: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch. */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ContentsListResponse"];
            404: components["responses"]["notFound"];
        };
    };
    repoChangeFiles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChangeFilesOptions"];
            };
        };
        responses: {
            201: components["responses"]["FilesResponse"];
            403: components["responses"]["error"];
            404: components["responses"]["notFound"];
            422: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetContentsExt: {
        parameters: {
            query?: {
                /** @description the name of the commit/branch/tag, default to the repositorys default branch. */
                ref?: string;
                /** @description By default this API's response only contains file's metadata. Use comma-separated "includes" options to retrieve more fields. Option "file_content" will try to retrieve the file content, "lfs_metadata" will try to retrieve LFS metadata, "commit_metadata" will try to retrieve commit metadata, and "commit_message" will try to retrieve commit message. */
                includes?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the dir, file, symlink or submodule in the repo. Swagger requires path parameter to be "required", you can leave it empty or pass a single dot (".") to get the root directory. */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ContentsExtResponse"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetContents: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch. */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the dir, file, symlink or submodule in the repo */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ContentsResponse"];
            404: components["responses"]["notFound"];
        };
    };
    repoUpdateFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the file to update */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateFileOptions"];
            };
        };
        responses: {
            200: components["responses"]["FileResponse"];
            403: components["responses"]["error"];
            404: components["responses"]["notFound"];
            422: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoCreateFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the file to create */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateFileOptions"];
            };
        };
        responses: {
            201: components["responses"]["FileResponse"];
            403: components["responses"]["error"];
            404: components["responses"]["notFound"];
            422: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoDeleteFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the file to delete */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DeleteFileOptions"];
            };
        };
        responses: {
            200: components["responses"]["FileDeleteResponse"];
            400: components["responses"]["error"];
            403: components["responses"]["error"];
            404: components["responses"]["error"];
            422: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoApplyDiffPatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ApplyDiffPatchFileOptions"];
            };
        };
        responses: {
            200: components["responses"]["FileResponse"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetEditorConfig: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch. */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description filepath of file to get */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
        };
    };
    repoGetFileContents: {
        parameters: {
            query: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch. */
                ref?: string;
                /** @description The JSON encoded body (see the POST request): {"files": ["filename1", "filename2"]} */
                body: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ContentsListResponse"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetFileContentsPost: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch. */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetFilesOptions"];
                "text/plain": components["schemas"]["GetFilesOptions"];
            };
        };
        responses: {
            200: components["responses"]["ContentsListResponse"];
            404: components["responses"]["notFound"];
        };
    };
    listForks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            404: components["responses"]["notFound"];
        };
    };
    createFork: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to fork */
                owner: string;
                /** @description name of the repo to fork */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateForkOption"];
                "text/plain": components["schemas"]["CreateForkOption"];
            };
        };
        responses: {
            202: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            /** @description The repository with the same name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            422: components["responses"]["validationError"];
        };
    };
    GetBlob: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description sha of the commit */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GitBlobResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetSingleCommit: {
        parameters: {
            query?: {
                /** @description include diff stats for every commit (disable for speedup, default 'true') */
                stat?: boolean;
                /** @description include verification for every commit (disable for speedup, default 'true') */
                verification?: boolean;
                /** @description include a list of affected files for every commit (disable for speedup, default 'true') */
                files?: boolean;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description a git ref or commit sha */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Commit"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoDownloadCommitDiffOrPatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description SHA of the commit to get */
                sha: string;
                /** @description whether the output is diff or patch */
                diffType: "diff" | "patch";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["string"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetNote: {
        parameters: {
            query?: {
                /** @description include verification for every commit (disable for speedup, default 'true') */
                verification?: boolean;
                /** @description include a list of affected files for every commit (disable for speedup, default 'true') */
                files?: boolean;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description a git ref or commit sha */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Note"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoListAllGitRefs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ReferenceList"];
            404: components["responses"]["notFound"];
        };
    };
    repoListGitRefs: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description part or full name of the ref */
                ref: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ReferenceList"];
            404: components["responses"]["notFound"];
        };
    };
    GetAnnotatedTag: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags. */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AnnotatedTag"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    GetTree: {
        parameters: {
            query?: {
                /** @description show all directories and files */
                recursive?: boolean;
                /** @description page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page */
                page?: number;
                /** @description number of items per page */
                per_page?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description sha of the commit */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GitTreeResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoListHooks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["HookList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateHookOption"];
            };
        };
        responses: {
            201: components["responses"]["Hook"];
            404: components["responses"]["notFound"];
        };
    };
    repoListGitHooks: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GitHookList"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetGitHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the hook to get */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GitHook"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteGitHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the hook to get */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoEditGitHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the hook to get */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditGitHookOption"];
                "text/plain": components["schemas"]["EditGitHookOption"];
            };
        };
        responses: {
            200: components["responses"]["GitHook"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the hook to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Hook"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the hook to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoEditHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the hook */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditHookOption"];
                "text/plain": components["schemas"]["EditHookOption"];
            };
        };
        responses: {
            200: components["responses"]["Hook"];
            404: components["responses"]["notFound"];
        };
    };
    repoTestHook: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the hook to test */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetIssueConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepoIssueConfig"];
            404: components["responses"]["notFound"];
        };
    };
    repoValidateIssueConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepoIssueConfigValidation"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetIssueTemplates: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IssueTemplates"];
            404: components["responses"]["notFound"];
        };
    };
    issueListIssues: {
        parameters: {
            query?: {
                /** @description whether issue is open or closed */
                state?: "closed" | "open" | "all";
                /** @description comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded */
                labels?: string;
                /** @description search string */
                q?: string;
                /** @description filter by type (issues / pulls) if set */
                type?: "issues" | "pulls";
                /** @description comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded */
                milestones?: string;
                /** @description Only show items updated after the given time. This is a timestamp in RFC 3339 format */
                since?: string;
                /** @description Only show items updated before the given time. This is a timestamp in RFC 3339 format */
                before?: string;
                /** @description Only show items which were created by the given user */
                created_by?: string;
                /** @description Only show items for which the given user is assigned */
                assigned_by?: string;
                /** @description Only show items in which the given user was mentioned */
                mentioned_by?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IssueList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCreateIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateIssueOption"];
            };
        };
        responses: {
            201: components["responses"]["Issue"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            412: components["responses"]["error"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueGetRepoComments: {
        parameters: {
            query?: {
                /** @description if provided, only comments updated since the provided time are returned. */
                since?: string;
                /** @description if provided, only comments updated before the provided time are returned. */
                before?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CommentList"];
            404: components["responses"]["notFound"];
        };
    };
    issueGetComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Comment"];
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of comment to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueEditComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditIssueCommentOption"];
        responses: {
            200: components["responses"]["Comment"];
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueListIssueCommentAttachments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AttachmentList"];
            404: components["responses"]["error"];
        };
    };
    issueCreateIssueCommentAttachment: {
        parameters: {
            query?: {
                /** @description name of the attachment */
                name?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["issueCreateIssueCommentAttachment"];
        responses: {
            201: components["responses"]["Attachment"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["error"];
            413: components["responses"]["error"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueGetIssueCommentAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment */
                id: number;
                /** @description id of the attachment to get */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Attachment"];
            404: components["responses"]["error"];
        };
    };
    issueDeleteIssueCommentAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment */
                id: number;
                /** @description id of the attachment to delete */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueEditIssueCommentAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment */
                id: number;
                /** @description id of the attachment to edit */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditAttachmentOptions"];
        responses: {
            201: components["responses"]["Attachment"];
            404: components["responses"]["error"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueGetCommentReactions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ReactionList"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issuePostCommentReaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditReactionOption"];
        responses: {
            200: components["responses"]["Reaction"];
            201: components["responses"]["Reaction"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteCommentReaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the comment to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditReactionOption"];
        responses: {
            200: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoListPinnedIssues: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IssueList"];
            404: components["responses"]["notFound"];
        };
    };
    issueGetIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to get */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Issue"];
            404: components["responses"]["notFound"];
        };
    };
    issueDelete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of issue to delete */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueEditIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to edit */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditIssueOption"];
            };
        };
        responses: {
            201: components["responses"]["Issue"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            412: components["responses"]["error"];
        };
    };
    issueListIssueAttachments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AttachmentList"];
            404: components["responses"]["error"];
        };
    };
    issueCreateIssueAttachment: {
        parameters: {
            query?: {
                /** @description name of the attachment */
                name?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["issueCreateIssueCommentAttachment"];
        responses: {
            201: components["responses"]["Attachment"];
            400: components["responses"]["error"];
            404: components["responses"]["error"];
            413: components["responses"]["error"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueGetIssueAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description id of the attachment to get */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Attachment"];
            404: components["responses"]["error"];
        };
    };
    issueDeleteIssueAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description id of the attachment to delete */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueEditIssueAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description id of the attachment to edit */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditAttachmentOptions"];
        responses: {
            201: components["responses"]["Attachment"];
            404: components["responses"]["error"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueListBlocks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IssueList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCreateIssueBlocking: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["IssueMeta"];
        responses: {
            201: components["responses"]["Issue"];
            /** @description the issue does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    issueRemoveIssueBlocking: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["IssueMeta"];
        responses: {
            200: components["responses"]["Issue"];
            404: components["responses"]["notFound"];
        };
    };
    issueGetComments: {
        parameters: {
            query?: {
                /** @description if provided, only comments updated since the specified time are returned. */
                since?: string;
                /** @description if provided, only comments updated before the provided time are returned. */
                before?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CommentList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCreateComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateIssueCommentOption"];
            };
        };
        responses: {
            201: components["responses"]["Comment"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueDeleteCommentDeprecated: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description this parameter is ignored */
                index: number;
                /** @description id of comment to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueEditCommentDeprecated: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description this parameter is ignored */
                index: number;
                /** @description id of the comment to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditIssueCommentOption"];
        responses: {
            200: components["responses"]["Comment"];
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueEditIssueDeadline: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to create or update a deadline on */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditDeadlineOption"];
            };
        };
        responses: {
            201: components["responses"]["IssueDeadline"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueListIssueDependencies: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IssueList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCreateIssueDependencies: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["IssueMeta"];
        responses: {
            201: components["responses"]["Issue"];
            /** @description the issue does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueRemoveIssueDependencies: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["IssueMeta"];
        responses: {
            200: components["responses"]["Issue"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    issueGetLabels: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LabelList"];
            404: components["responses"]["notFound"];
        };
    };
    issueReplaceLabels: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["IssueLabelsOption"];
        responses: {
            200: components["responses"]["LabelList"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueAddLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["IssueLabelsOption"];
        responses: {
            200: components["responses"]["LabelList"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueClearLabels: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueRemoveLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description id of the label to remove */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    issueLockIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["LockIssueOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueUnlockIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    pinIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of issue to pin */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    unpinIssue: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of issue to unpin */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    moveIssuePin: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of issue */
                index: number;
                /** @description the new position */
                position: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueGetIssueReactions: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ReactionList"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issuePostIssueReaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditReactionOption"];
        responses: {
            200: components["responses"]["Reaction"];
            201: components["responses"]["Reaction"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteIssueReaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditReactionOption"];
        responses: {
            200: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteStopWatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to stop the stopwatch on */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            /** @description Not repo writer, user does not have rights to toggle stopwatch */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
            /** @description Cannot cancel a non-existent stopwatch */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    issueStartStopWatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to create the stopwatch on */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: components["responses"]["empty"];
            /** @description Not repo writer, user does not have rights to toggle stopwatch */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
            /** @description Cannot start a stopwatch again if it already exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    issueStopStopWatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to stop the stopwatch on */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: components["responses"]["empty"];
            /** @description Not repo writer, user does not have rights to toggle stopwatch */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
            /** @description Cannot stop a non-existent stopwatch */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    issueSubscriptions: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCheckSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WatchInfo"];
            404: components["responses"]["notFound"];
        };
    };
    issueAddSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description username of the user to subscribe the issue to */
                user: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Already subscribed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Successfully Subscribed */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User can only subscribe itself if he is no admin */
            304: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description username of the user to unsubscribe from an issue */
                user: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Already unsubscribed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Successfully Unsubscribed */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description User can only subscribe itself if he is no admin */
            304: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
        };
    };
    issueGetCommentsAndTimeline: {
        parameters: {
            query?: {
                /** @description if provided, only comments updated since the specified time are returned. */
                since?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
                /** @description if provided, only comments updated before the provided time are returned. */
                before?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TimelineList"];
            404: components["responses"]["notFound"];
        };
    };
    issueTrackedTimes: {
        parameters: {
            query?: {
                /** @description optional filter by user (available for issue managers) */
                user?: string;
                /** @description Only show times updated after the given time. This is a timestamp in RFC 3339 format */
                since?: string;
                /** @description Only show times updated before the given time. This is a timestamp in RFC 3339 format */
                before?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TrackedTimeList"];
            404: components["responses"]["notFound"];
        };
    };
    issueAddTime: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AddTimeOption"];
            };
        };
        responses: {
            200: components["responses"]["TrackedTime"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueResetTime: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue to add tracked time to */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteTime: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the issue */
                index: number;
                /** @description id of time to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoListKeys: {
        parameters: {
            query?: {
                /** @description the key_id to search for */
                key_id?: number;
                /** @description fingerprint of the key */
                fingerprint?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeployKeyList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateKeyOption"];
        responses: {
            201: components["responses"]["DeployKey"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the key to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeployKey"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the key to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    issueListLabels: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LabelList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCreateLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateLabelOption"];
        responses: {
            201: components["responses"]["Label"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    issueGetLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the label to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Label"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the label to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    issueEditLabel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the label to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditLabelOption"];
        responses: {
            200: components["responses"]["Label"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetLanguages: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LanguageStatistics"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetLicenses: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LicensesList"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetRawFileOrLFS: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the file to get, it should be "{ref}/{filepath}". If there is no ref could be inferred, it will be treated as the default branch */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns raw file content. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            404: components["responses"]["notFound"];
        };
    };
    repoMergeUpstream: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MergeUpstreamRequest"];
                "text/plain": components["schemas"]["MergeUpstreamRequest"];
            };
        };
        responses: {
            200: components["responses"]["MergeUpstreamResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    issueGetMilestonesList: {
        parameters: {
            query?: {
                /** @description Milestone state, Recognized values are open, closed and all. Defaults to "open" */
                state?: string;
                /** @description filter by milestone name */
                name?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MilestoneList"];
            404: components["responses"]["notFound"];
        };
    };
    issueCreateMilestone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateMilestoneOption"];
            };
        };
        responses: {
            201: components["responses"]["Milestone"];
            404: components["responses"]["notFound"];
        };
    };
    issueGetMilestone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description the milestone to get, identified by ID and if not available by name */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Milestone"];
            404: components["responses"]["notFound"];
        };
    };
    issueDeleteMilestone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description the milestone to delete, identified by ID and if not available by name */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    issueEditMilestone: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description the milestone to edit, identified by ID and if not available by name */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditMilestoneOption"];
            };
        };
        responses: {
            200: components["responses"]["Milestone"];
            404: components["responses"]["notFound"];
        };
    };
    repoMirrorSync: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to sync */
                owner: string;
                /** @description name of the repo to sync */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoNewPinAllowed: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepoNewIssuePinsAllowed"];
            404: components["responses"]["notFound"];
        };
    };
    notifyGetRepoList: {
        parameters: {
            query?: {
                /** @description If true, show notifications marked as read. Default value is false */
                all?: boolean;
                /** @description Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned */
                "status-types"?: string[];
                /** @description filter notifications by subject type */
                "subject-type"?: ("issue" | "pull" | "commit" | "repository")[];
                /** @description Only show notifications updated after the given time. This is a timestamp in RFC 3339 format */
                since?: string;
                /** @description Only show notifications updated before the given time. This is a timestamp in RFC 3339 format */
                before?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationThreadList"];
        };
    };
    notifyReadRepoList: {
        parameters: {
            query?: {
                /** @description If true, mark all notifications on this repo. Default value is false */
                all?: string;
                /** @description Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread. */
                "status-types"?: string[];
                /** @description Status to mark notifications as. Defaults to read. */
                "to-status"?: string;
                /** @description Describes the last point that notifications were checked. Anything updated since this time will not be updated. */
                last_read_at?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            205: components["responses"]["NotificationThreadList"];
        };
    };
    repoListPullRequests: {
        parameters: {
            query?: {
                /** @description Filter by target base branch of the pull request */
                base_branch?: string;
                /** @description State of pull request */
                state?: "open" | "closed" | "all";
                /** @description Type of sort */
                sort?: "oldest" | "recentupdate" | "recentclose" | "leastupdate" | "mostcomment" | "leastcomment" | "priority";
                /** @description ID of the milestone */
                milestone?: number;
                /** @description Label IDs */
                labels?: number[];
                /** @description Filter by pull request author */
                poster?: string;
                /** @description Page number of results to return (1-based) */
                page?: number;
                /** @description Page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description Name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullRequestList"];
            404: components["responses"]["notFound"];
            500: components["responses"]["error"];
        };
    };
    repoCreatePullRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreatePullRequestOption"];
            };
        };
        responses: {
            201: components["responses"]["PullRequest"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["error"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoListPinnedPullRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullRequestList"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetPullRequestByBaseHead: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description base of the pull request to get */
                base: string;
                /** @description head of the pull request to get */
                head: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullRequest"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetPullRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to get */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullRequest"];
            404: components["responses"]["notFound"];
        };
    };
    repoEditPullRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to edit */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditPullRequestOption"];
            };
        };
        responses: {
            201: components["responses"]["PullRequest"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["error"];
            412: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    repoDownloadPullDiffOrPatch: {
        parameters: {
            query?: {
                /** @description whether to include binary file changes. if true, the diff is applicable with `git apply` */
                binary?: boolean;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to get */
                index: number;
                /** @description whether the output is diff or patch */
                diffType: "diff" | "patch";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["string"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetPullRequestCommits: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
                /** @description include verification for every commit (disable for speedup, default 'true') */
                verification?: boolean;
                /** @description include a list of affected files for every commit (disable for speedup, default 'true') */
                files?: boolean;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to get */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CommitList"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetPullRequestFiles: {
        parameters: {
            query?: {
                /** @description skip to given file */
                "skip-to"?: string;
                /** @description whitespace behavior */
                whitespace?: "ignore-all" | "ignore-change" | "ignore-eol" | "show-all";
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to get */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ChangedFileList"];
            404: components["responses"]["notFound"];
        };
    };
    repoPullRequestIsMerged: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description pull request has been merged */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description pull request has not been merged */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    repoMergePullRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to merge */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["MergePullRequestOption"];
                "text/plain": components["schemas"]["MergePullRequestOption"];
            };
        };
        responses: {
            200: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            405: components["responses"]["empty"];
            409: components["responses"]["error"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoCancelScheduledAutoMerge: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to merge */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoCreatePullReviewRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["PullReviewRequestOptions"];
        responses: {
            201: components["responses"]["PullReviewList"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoDeletePullReviewRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["PullReviewRequestOptions"];
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoListPullReviews: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullReviewList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreatePullReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePullReviewOptions"];
                "text/plain": components["schemas"]["CreatePullReviewOptions"];
            };
        };
        responses: {
            200: components["responses"]["PullReview"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetPullReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
                /** @description id of the review */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullReview"];
            404: components["responses"]["notFound"];
        };
    };
    repoSubmitPullReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
                /** @description id of the review */
                id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SubmitPullReviewOptions"];
                "text/plain": components["schemas"]["SubmitPullReviewOptions"];
            };
        };
        responses: {
            200: components["responses"]["PullReview"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoDeletePullReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
                /** @description id of the review */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetPullReviewComments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
                /** @description id of the review */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullReviewCommentList"];
            404: components["responses"]["notFound"];
        };
    };
    repoDismissPullReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
                /** @description id of the review */
                id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DismissPullReviewOptions"];
                "text/plain": components["schemas"]["DismissPullReviewOptions"];
            };
        };
        responses: {
            200: components["responses"]["PullReview"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoUnDismissPullReview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request */
                index: number;
                /** @description id of the review */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PullReview"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoUpdatePullRequest: {
        parameters: {
            query?: {
                /** @description how to update pull request */
                style?: "merge" | "rebase";
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description index of the pull request to get */
                index: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            409: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    repoListPushMirrors: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PushMirrorList"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoAddPushMirror: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreatePushMirrorOption"];
            };
        };
        responses: {
            200: components["responses"]["PushMirror"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoPushMirrorSync: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to sync */
                owner: string;
                /** @description name of the repo to sync */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["empty"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetPushMirrorByRemoteName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description remote name of push mirror */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PushMirror"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeletePushMirror: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description remote name of the pushMirror */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetRawFile: {
        parameters: {
            query?: {
                /** @description The name of the commit/branch/tag. Default to the repositorys default branch */
                ref?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description path of the file to get, it should be "{ref}/{filepath}". If there is no ref could be inferred, it will be treated as the default branch */
                filepath: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns raw file content. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            404: components["responses"]["notFound"];
        };
    };
    repoListReleases: {
        parameters: {
            query?: {
                /** @description filter (exclude / include) drafts, if you dont have repo write access none will show */
                draft?: boolean;
                /** @description filter (exclude / include) pre-releases */
                "pre-release"?: boolean;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ReleaseList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateRelease: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateReleaseOption"];
            };
        };
        responses: {
            201: components["responses"]["Release"];
            404: components["responses"]["notFound"];
            409: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetLatestRelease: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Release"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetReleaseByTag: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description tag name of the release to get */
                tag: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Release"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteReleaseByTag: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description tag name of the release to delete */
                tag: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetRelease: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Release"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteRelease: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoEditRelease: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditReleaseOption"];
            };
        };
        responses: {
            200: components["responses"]["Release"];
            404: components["responses"]["notFound"];
        };
    };
    repoListReleaseAttachments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AttachmentList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateReleaseAttachment: {
        parameters: {
            query?: {
                /** @description name of the attachment */
                name?: string;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description attachment to upload
                     */
                    attachment?: string;
                };
            };
        };
        responses: {
            201: components["responses"]["Attachment"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
            413: components["responses"]["error"];
        };
    };
    repoGetReleaseAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release */
                id: number;
                /** @description id of the attachment to get */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Attachment"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteReleaseAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release */
                id: number;
                /** @description id of the attachment to delete */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoEditReleaseAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the release */
                id: number;
                /** @description id of the attachment to edit */
                attachment_id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditAttachmentOptions"];
        responses: {
            201: components["responses"]["Attachment"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    repoGetReviewers: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    repoSigningKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description GPG armored public key */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    repoSigningKeySSH: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ssh public key */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    repoListStargazers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoListStatuses: {
        parameters: {
            query?: {
                /** @description type of sort */
                sort?: "oldest" | "recentupdate" | "leastupdate" | "leastindex" | "highestindex";
                /** @description type of state */
                state?: "pending" | "success" | "error" | "failure" | "warning";
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description sha of the commit */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CommitStatusList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description sha of the commit */
                sha: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateStatusOption"];
                "text/plain": components["schemas"]["CreateStatusOption"];
            };
        };
        responses: {
            201: components["responses"]["CommitStatus"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    repoListSubscribers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentCheckSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WatchInfo"];
            /** @description User is not watching this repo or repo do not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    userCurrentPutSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WatchInfo"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentDeleteSubscription: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoListTagProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TagProtectionList"];
        };
    };
    repoCreateTagProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateTagProtectionOption"];
            };
        };
        responses: {
            201: components["responses"]["TagProtection"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetTagProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of the tag protect to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TagProtection"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteTagProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of protected tag */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    repoEditTagProtection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description id of protected tag */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditTagProtectionOption"];
            };
        };
        responses: {
            200: components["responses"]["TagProtection"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoListTags: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results, default maximum page size is 50 */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TagList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateTag: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateTagOption"];
                "text/plain": components["schemas"]["CreateTagOption"];
            };
        };
        responses: {
            200: components["responses"]["Tag"];
            404: components["responses"]["notFound"];
            405: components["responses"]["empty"];
            409: components["responses"]["conflict"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetTag: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of tag */
                tag: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Tag"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteTag: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of tag to delete */
                tag: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            405: components["responses"]["empty"];
            409: components["responses"]["conflict"];
            422: components["responses"]["validationError"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoListTeams: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TeamList"];
            404: components["responses"]["notFound"];
        };
    };
    repoCheckTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description team name */
                team: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Team"];
            404: components["responses"]["notFound"];
            405: components["responses"]["error"];
        };
    };
    repoAddTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description team name */
                team: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            405: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    repoDeleteTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description team name */
                team: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            405: components["responses"]["error"];
            422: components["responses"]["validationError"];
        };
    };
    repoTrackedTimes: {
        parameters: {
            query?: {
                /** @description optional filter by user (available for issue managers) */
                user?: string;
                /** @description Only show times updated after the given time. This is a timestamp in RFC 3339 format */
                since?: string;
                /** @description Only show times updated before the given time. This is a timestamp in RFC 3339 format */
                before?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TrackedTimeList"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userTrackedTimes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description username of the user whose tracked times are to be listed */
                user: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TrackedTimeList"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoListTopics: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TopicNames"];
            404: components["responses"]["notFound"];
        };
    };
    repoUpdateTopics: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RepoTopicOptions"];
                "text/plain": components["schemas"]["RepoTopicOptions"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["invalidTopicsError"];
        };
    };
    repoAddTopic: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the topic to add */
                topic: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["invalidTopicsError"];
        };
    };
    repoDeleteTopic: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the topic to delete */
                topic: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["invalidTopicsError"];
        };
    };
    repoTransfer: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to transfer */
                owner: string;
                /** @description name of the repo to transfer */
                repo: string;
            };
            cookie?: never;
        };
        /** @description Transfer Options */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TransferRepoOption"];
                "text/plain": components["schemas"]["TransferRepoOption"];
            };
        };
        responses: {
            202: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    acceptRepoTransfer: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to transfer */
                owner: string;
                /** @description name of the repo to transfer */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            202: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    rejectRepoTransfer: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to transfer */
                owner: string;
                /** @description name of the repo to transfer */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    repoCreateWikiPage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateWikiPageOptions"];
        responses: {
            201: components["responses"]["WikiPage"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetWikiPage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the page */
                pageName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WikiPage"];
            404: components["responses"]["notFound"];
        };
    };
    repoDeleteWikiPage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the page */
                pageName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoEditWikiPage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the page */
                pageName: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateWikiPageOptions"];
        responses: {
            200: components["responses"]["WikiPage"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            423: components["responses"]["repoArchivedError"];
        };
    };
    repoGetWikiPages: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WikiPageList"];
            404: components["responses"]["notFound"];
        };
    };
    repoGetWikiPageRevisions: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
            };
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
                /** @description name of the page */
                pageName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WikiCommitList"];
            404: components["responses"]["notFound"];
        };
    };
    generateRepo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the template repository */
                template_owner: string;
                /** @description name of the template repository */
                template_repo: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["GenerateRepoOption"];
            };
        };
        responses: {
            201: components["responses"]["Repository"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            /** @description The repository with the same name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            422: components["responses"]["validationError"];
        };
    };
    repoGetByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the repo to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Repository"];
            404: components["responses"]["notFound"];
        };
    };
    getGeneralAPISettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GeneralAPISettings"];
        };
    };
    getGeneralAttachmentSettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GeneralAttachmentSettings"];
        };
    };
    getGeneralRepositorySettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GeneralRepoSettings"];
        };
    };
    getGeneralUISettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GeneralUISettings"];
        };
    };
    getSigningKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description GPG armored public key */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    getSigningKeySSH: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ssh public key */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    orgGetTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Team"];
            404: components["responses"]["notFound"];
        };
    };
    orgDeleteTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description team deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["notFound"];
        };
    };
    orgEditTeam: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team to edit */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["EditTeamOption"];
            };
        };
        responses: {
            200: components["responses"]["Team"];
            404: components["responses"]["notFound"];
        };
    };
    orgListTeamActivityFeeds: {
        parameters: {
            query?: {
                /** @description the date of the activities to be found */
                date?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActivityFeedsList"];
            404: components["responses"]["notFound"];
        };
    };
    orgListTeamMembers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    orgListTeamMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
                /** @description username of the user whose data is to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["User"];
            404: components["responses"]["notFound"];
        };
    };
    orgAddTeamMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
                /** @description username of the user to add to a team */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    orgRemoveTeamMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
                /** @description username of the user to remove from a team */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    orgListTeamRepos: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            404: components["responses"]["notFound"];
        };
    };
    orgListTeamRepo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
                /** @description organization that owns the repo to list */
                org: string;
                /** @description name of the repo to list */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Repository"];
            404: components["responses"]["notFound"];
        };
    };
    orgAddTeamRepository: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
                /** @description organization that owns the repo to add */
                org: string;
                /** @description name of the repo to add */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    orgRemoveTeamRepository: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the team */
                id: number;
                /** @description organization that owns the repo to remove */
                org: string;
                /** @description name of the repo to remove */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    topicSearch: {
        parameters: {
            query: {
                /** @description keywords to search */
                q: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TopicListResponse"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userGetCurrent: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["User"];
        };
    };
    getUserWorkflowJobs: {
        parameters: {
            query?: {
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowJobsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getUserRunners: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunnersResponse"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    userGetRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    userCreateRunnerRegistrationToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RegistrationToken"];
        };
    };
    getUserRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["schemas"]["ActionRunner"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteUserRunner: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the runner */
                runner_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description runner has been deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getUserWorkflowRuns: {
        parameters: {
            query?: {
                /** @description workflow event name */
                event?: string;
                /** @description workflow branch */
                branch?: string;
                /** @description workflow status (pending, queued, in_progress, failure, success, skipped) */
                status?: string;
                /** @description triggered by user */
                actor?: string;
                /** @description triggering sha of the workflow run */
                head_sha?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorkflowRunsList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    updateUserSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the secret */
                secretname: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateOrUpdateSecretOption"];
        responses: {
            /** @description response when creating a secret */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when updating a secret */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    deleteUserSecret: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the secret */
                secretname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description delete one secret of the user */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getUserVariablesList: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["VariableList"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    getUserVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActionVariable"];
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    updateUserVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["UpdateVariableOption"];
        responses: {
            /** @description response when updating a variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when updating a variable */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    createUserVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateVariableOption"];
        responses: {
            /** @description successfully created the user-level variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            /** @description variable name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteUserVariable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the variable */
                variablename: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description response when deleting a variable */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description response when deleting a variable */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["error"];
            404: components["responses"]["notFound"];
        };
    };
    userGetOauth2Application: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OAuth2ApplicationList"];
        };
    };
    userCreateOAuth2Application: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateOAuth2ApplicationOptions"];
        responses: {
            201: components["responses"]["OAuth2Application"];
            400: components["responses"]["error"];
        };
    };
    userGetOAuth2Application: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Application ID to be found */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OAuth2Application"];
            404: components["responses"]["notFound"];
        };
    };
    userDeleteOAuth2Application: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description token to be deleted */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    userUpdateOAuth2Application: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description application to be updated */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateOAuth2ApplicationOptions"];
        responses: {
            200: components["responses"]["OAuth2Application"];
            404: components["responses"]["notFound"];
        };
    };
    userUpdateAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["UpdateUserAvatarOption"];
        responses: {
            204: components["responses"]["empty"];
        };
    };
    userDeleteAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
        };
    };
    userListBlocks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
        };
    };
    userCheckUserBlock: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user to check */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    userBlockUser: {
        parameters: {
            query?: {
                /** @description optional note for the block */
                note?: string;
            };
            header?: never;
            path: {
                /** @description username of the user to block */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    userUnblockUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user to unblock */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    userListEmails: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["EmailList"];
        };
    };
    userAddEmail: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateEmailOption"];
                "text/plain": components["schemas"]["CreateEmailOption"];
            };
        };
        responses: {
            201: components["responses"]["EmailList"];
            422: components["responses"]["validationError"];
        };
    };
    userDeleteEmail: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DeleteEmailOption"];
                "text/plain": components["schemas"]["DeleteEmailOption"];
            };
        };
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentListFollowers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
        };
    };
    userCurrentListFollowing: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
        };
    };
    userCurrentCheckFollowing: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user to check for authenticated followers */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentPutFollow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user to follow */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentDeleteFollow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user to unfollow */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    getVerificationToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["string"];
            404: components["responses"]["notFound"];
        };
    };
    userVerifyGPGKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: components["responses"]["GPGKey"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    userCurrentListGPGKeys: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GPGKeyList"];
        };
    };
    userCurrentPostGPGKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateGPGKeyOption"];
            };
        };
        responses: {
            201: components["responses"]["GPGKey"];
            404: components["responses"]["notFound"];
            422: components["responses"]["validationError"];
        };
    };
    userCurrentGetGPGKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of key to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GPGKey"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentDeleteGPGKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of key to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userListHooks: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["HookList"];
        };
    };
    userCreateHook: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CreateHookOption"];
        responses: {
            201: components["responses"]["Hook"];
        };
    };
    userGetHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the hook to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Hook"];
        };
    };
    userDeleteHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the hook to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
        };
    };
    userEditHook: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of the hook to update */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["EditHookOption"];
        responses: {
            200: components["responses"]["Hook"];
        };
    };
    userCurrentListKeys: {
        parameters: {
            query?: {
                /** @description fingerprint of the key */
                fingerprint?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PublicKeyList"];
        };
    };
    userCurrentPostKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateKeyOption"];
        responses: {
            201: components["responses"]["PublicKey"];
            422: components["responses"]["validationError"];
        };
    };
    userCurrentGetKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of key to get */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PublicKey"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentDeleteKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description id of key to delete */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    orgListCurrentUserOrgs: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrganizationList"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentListRepos: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
        };
    };
    createCurrentUserRepo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateRepoOption"];
        responses: {
            201: components["responses"]["Repository"];
            400: components["responses"]["error"];
            /** @description The repository with the same name already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            422: components["responses"]["validationError"];
        };
    };
    getUserSettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserSettings"];
        };
    };
    updateUserSettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UserSettingsOptions"];
                "text/plain": components["schemas"]["UserSettingsOptions"];
            };
        };
        responses: {
            200: components["responses"]["UserSettings"];
        };
    };
    userCurrentListStarred: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            403: components["responses"]["forbidden"];
        };
    };
    userCurrentCheckStarring: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo */
                owner: string;
                /** @description name of the repo */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentPutStar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to star */
                owner: string;
                /** @description name of the repo to star */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userCurrentDeleteStar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description owner of the repo to unstar */
                owner: string;
                /** @description name of the repo to unstar */
                repo: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userGetStopWatches: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["StopWatchList"];
        };
    };
    userCurrentListSubscriptions: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
        };
    };
    userListTeams: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TeamList"];
        };
    };
    userCurrentTrackedTimes: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
                /** @description Only show times updated after the given time. This is a timestamp in RFC 3339 format */
                since?: string;
                /** @description Only show times updated before the given time. This is a timestamp in RFC 3339 format */
                before?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TrackedTimeList"];
        };
    };
    userSearch: {
        parameters: {
            query?: {
                /** @description keyword */
                q?: string;
                /** @description ID of the user to search for */
                uid?: number;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SearchResults of a successful search */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["User"][];
                        ok?: boolean;
                    };
                };
            };
        };
    };
    userGet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose data is to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["User"];
            404: components["responses"]["notFound"];
        };
    };
    userListActivityFeeds: {
        parameters: {
            query?: {
                /** @description if true, only show actions performed by the requested user */
                "only-performed-by"?: boolean;
                /** @description the date of the activities to be found */
                date?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose activity feeds are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ActivityFeedsList"];
            404: components["responses"]["notFound"];
        };
    };
    userListFollowers: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose followers are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    userListFollowing: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose followed users are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserList"];
            404: components["responses"]["notFound"];
        };
    };
    userCheckFollowing: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the following user */
                username: string;
                /** @description username of the followed user */
                target: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            404: components["responses"]["notFound"];
        };
    };
    userListGPGKeys: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose GPG key list is to be obtained */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GPGKeyList"];
            404: components["responses"]["notFound"];
        };
    };
    userGetHeatmapData: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose heatmap is to be obtained */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserHeatmapData"];
            404: components["responses"]["notFound"];
        };
    };
    userListKeys: {
        parameters: {
            query?: {
                /** @description fingerprint of the key */
                fingerprint?: string;
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose public keys are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PublicKeyList"];
            404: components["responses"]["notFound"];
        };
    };
    orgListUserOrgs: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose organizations are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrganizationList"];
            404: components["responses"]["notFound"];
        };
    };
    orgGetUserPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose permissions are to be obtained */
                username: string;
                /** @description name of the organization */
                org: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrganizationPermissions"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userListRepos: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose owned repos are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            404: components["responses"]["notFound"];
        };
    };
    userListStarred: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose starred repos are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
        };
    };
    userListSubscriptions: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of the user whose watched repos are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RepositoryList"];
            404: components["responses"]["notFound"];
        };
    };
    userGetTokens: {
        parameters: {
            query?: {
                /** @description page number of results to return (1-based) */
                page?: number;
                /** @description page size of results */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description username of to user whose access tokens are to be listed */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AccessTokenList"];
            403: components["responses"]["forbidden"];
        };
    };
    userCreateToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose token is to be created */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateAccessTokenOption"];
            };
        };
        responses: {
            201: components["responses"]["AccessToken"];
            400: components["responses"]["error"];
            403: components["responses"]["forbidden"];
        };
    };
    userDeleteAccessToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description username of the user whose token is to be deleted */
                username: string;
                /** @description token to be deleted, identified by ID and if not available by name */
                token: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: components["responses"]["empty"];
            403: components["responses"]["forbidden"];
            404: components["responses"]["notFound"];
            422: components["responses"]["error"];
        };
    };
    getVersion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ServerVersion"];
        };
    };
}
